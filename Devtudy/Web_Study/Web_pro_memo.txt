=======================================================================================
#1 웹 프로그래밍 개요

* Javascript의 발전
  - 브라우저: Netscape -> Chrome
  - Node.js의 등장으로 Javascript가 사용되기 시작됨

* Javascript로 할 수 있는 일
  1) Web client application 개발
    - Web browser에서 실행 가능한 유일한 프로그래밍 언어
  2) Web server 개발
    - 데이터 처리와 예외 처리 복잡(by Node.js)
    - 처리 속도 빠름(by Node.js)
  3) Mobile application 개발
    - 페이스북의 React Native 이용
  4) Desktop application 개발
    - 일렉트론(Electron) 모듈 이용
    - JavaScript, HTML, CSS를 이용
  5) 게임 개발
    - 원래 게임은 서버, 클라이언트 모두 C++로 제작했다.
  
* Node.js 개념
  - 크롬 V8 JavaScript 엔진으로 빌드된 JavaScript 런타임 실행 환경
  - 자바스크립트로 만든 프로그램을 실행하게 해준다.
  - 서버의 역할도 수행할 수 있는 자바스크립트 런타임
  - 서버 실행을 위한 http/https/http2 모듈 이용

* 런타임(runtime)
  - 특정 언어로 만든 프로그램들을 실행할 수 있게 해주는 가상 머신(크롬의 V8 엔진)의 상태

* Node.js의 내부 구조(V8 + libuv)
  - V8 엔진: 오픈 소스 JavaScript 엔진 -> 속도 개선
  - libuv: 이벤트 기반, 논 블로킹 I/O(+비동기) 모델 라이브러리

* 이벤트 기반
  - 이벤트가 발생할 때, 미리 지정해둔 작업 수행
  ex) 클릭, 네트워크 요청, 타이머 등
  - 이벤트 리스너(Listener): 이벤트를 등록하는 함수
  - **콜백(Call-back) 함수: 이벤트가 발생했을 때 실행될 함수

* 논블로킹(Non-blocking I/O)
  - 오래 걸리는 함수를 백그라운드로 보내서 다음 코드가 먼저 실행되게 함
  - 백그라운드에서 병렬로 실행됨
  ex) I/O 작업(파일 시스템 접근, 네트워크 요청), 압축, 암호화 등
  
  - I/O 작업이 많을수록 Node.js 활용성 극대화

* 프로세스(Process) vs 스레드(Thread)
  - 프로세스: OS단에서 할당하는 작업 단위, 프로세스간 자원 공유X
  - 스레드: 프로세스 내에서 실행되는 작업 단위, 부모 프로세스 자원 공유O

* Node Process
  - 노드 프로세스는 멀티스레드로 돌아가지만 다룰 수 있는 스레드는 하나다.
  - Node v14부터는 멀티스레드를 사용 가능하다(worker_threads 모듈 사용)

* 싱글 스레드 vs 멀티 스레드
  - 싱글 스레드: 프로그래밍 난이도 쉬움, CPU와 메모리 자원 적게 사용
  - 멀티 스레드: 프로그래밍 난이도 어려움, 스레드에 대한 처리(생성, 소멸) 비용 발생, 스레드 수만큼 자원 많이 사용

* Node 서버의 장단점
  - 장점
    : I/O 작업이 많은 서버로 적합
    : 웹 서버 내장
    : JSON 형식과 호환
  - 단점
    : CPU 작업이 많은 서버 부적합
    : 서버 규모 커졌을 때, 서버 관리 어려움
    : 다른 플랫폼과 비교해서 성능이 조금 떨어짐

* Node 클라이언트
  - 웹 프레임워크: Angular, React, Vue, Meteor 등
  - 모바일 앱 프레임워크: React Native
  - 데스크탑 개발 도구: Electron(Atom, Slack, VSCode, Discord 제작)

* Node 설치(Linux)
  1) sudo apt-get update
  2) sudo apt-get install -y nodejs

=======================================================================================
#2 Javascript 기초(step 1)

* Javascript 기본 용어
  - 표현식(Expression): 값
  - 문장(Statement): 표현식이 하나 이상 모일 경우, 마지막에 종결 의미로 세미콜론(';')
  - 프로그램: 문장들이 모일 경우
  - 키워드: Javascript에서 특별한 의미가 부여된 단어
    ex) break, let, in, var, instanceof, case, catch

  - 식별자: 이름을 붙일 때 사용하는 단어
    1) 키워드 사용 불가
    2) 특수 문자는 '_', '$'만 허용
    3) 숫자로 시작 불가
    4) 공백 입력 불가
    5) 사용 규칙: 
      - 생성자는 대문자로 시작
      - 변수, 함수, 속성, 메소드는 소문자로 시작
      - 여러 단어로 된 식별자는 각 단어의 첫 글자를 대문자로 함(카멜 표기법)
    6) 종류: 객체 안에는 (속성) / (메소드) = (변수, 상수) / (함수)
  - 주석: // or /*, */

* 출력(in node.js)
  - console.log("문자열")로 출력
  - REPL(Read Eval Print Loop): 터미널에서 [node]만 입력하여 출력을 바로 확인 가능
  - 웹 브라우저 활용: Chrome의 F12(검사)에서 Console(ESC)탭으로 출력을 바로 확인 가능

* 자료형
  - 숫자: Number에 int, float, short, byte 모두 포함됨
      1) 연산자 우선순위는 C 언어와 같다.
      2) 숫자와 문자열을 더하면(+) 문자열이 된다
  - 문자열: string, char가 string으로 합쳐짐
      1) 큰따옴표 or 작은따옴표 사용
      2) JSON 사용은 only 큰따옴표
      3) 큰따옴표, 작은따옴표를 출력하려면 '\'(이스케이프 문자)를 추가하여 입력 가능
      4) '+'로만 문자열 연결 가능
      5) 문자열[숫자]로 문자를 선택 가능('[]' 선택 연산자)
      6) 템플릿 문자열(ECMA6): '`'(백틱 문자), '$'이용
        ex. `52 + 100 = ${52 + 100}` -> 52 + 100 = 152 출력됨
      7) '+식별자': '+'가 단항 연산자의 경우 숫자(Number)로 형 변환
  - 불(Boolean): 참(true=1), 거짓(false=0) 표현
      1) 비교 연산자: '==', '!=', '>', '<', '>=', '<='
      2) 논리 연산자: '!', '||', '&&'
      3) !!로 Boolean형으로 형 변환

* 변수
  - 예전에는 'var'를 사용하였지만 현재는 'let'으로 사용한다
  - 변수 선언 후, 초기화 안하면 undefined 타입
  - Hoist: 초기화가 아닌 선언만 코드 위로 끌어올린다(선언 없이 사용 가능)
    ex 1) Hoisting - 선언되지 않아도 에러 발생X
      var num = 1;    // 선언하면서 초기화

    ex 2) ex 1) -> ex 2)로 바뀐다(실제로는 "Lexical Environment"에 추가)
      var num;
      num = 1;

  - 'var' 대신 'let'을 사용:
      1) Hoisting 문제 해결
        : 'let'은 Hoisting이 되긴 하지만 TDZ(Temporal Dead Zone)로 지정 -> 블록을 넘어서 초기화 X -> error 발생
        : 'var'는 undefined로 지정 -> 블록을 넘어서 초기화 -> error 발생 X
      2) 변수 중복 선언 문제 해결 
      3) 전역(함수 스코프) 변수 남발 문제 해결
  - 복합 대입 연산자: '+=', '-=', '/=', '*='
  - 증감 연산자: '변수++', '변수--', '++변수', '--변수'
  - 상수: 항상 같은 수(변하지 않는 수), const 키워드 이용

* 자료형(6가지)
  - typeof 이용   ex. typeof(식별자) or typeof 식별자
      1) string: 문자열
      2) number: 숫자
      3) boolean: 참, 거짓
      4) function: 함수
      5) object: 객체
      6) undefined: 변수를 선언했으나 초기화하지 않은 자료형

* 강제 자료형 변환
  - Number(): 숫자로 자료형 변환(리턴),
     ??타입 -> Number 타입(Number로 변경 불가시 NaN 값)
  - String(): 문자열로 자료형 변환(리턴),
     ??타입 -> String 타입
  - Boolean(): 불로 자료형 변환(리턴),
     ??타입 -> Boolean 타입

* NaN(Not a Number)
  - 숫자(Number) 자료형이지만 숫자가 아닌 값
  - NaN끼리 비교하면 무조건 다르다(false)
  - isNaN(변수명)으로 NaN 인지 확인
  - NaN은 Boolean의 false로 변환 + (0, "빈 문자열", null, undefined)도 false

* ('==', '!=') vs ('===', '!==')
  - ('==', '!='): 비교 연산자, 형 변환 수행 후 비교, 값만 비교
  - ('===', '!=='): 일치 연산자, 자료형까지 검사하여 비교, **권장

=======================================================================================
#3 Javascript 기초(step 2)

* 조건문
  - (if)-(else if)-(else)
  - (switch)-(case)
  - 삼항 연산자(?): <불 표현식> '?' <참> : <거짓>

* 반복문
  - 배열: 여러 개의 자료를 한꺼번에 다루는 자료형, 여러 자료형 섞어서 가능
      ex) let 이름 = [A 자료, B 자료, C 자료, D 자료];
  - while 문: 조건이 true일 경우까지 반복
  - for 문: 일반적인 반복문
  - for...in 문: index(인덱스), key로 접근, enumerables, 순서가 없음, JSON Objects(객체)
      ex) for(let index in array){i번째...array[i]}
  - for...of 문: value(요소), , value로 접근, iterables, 순서가 있음, array(배열)
      ex) for(let item of array){item}
  - break 키워드: 반복문 탈출 키워드
  - continue 키워드: 현재 반복 멈추고 다음 반복문 진행(바로 조건 비교)

* 스코프(Scope): 변수 선언 시, 변수를 사용할 수 있는 범위
  - 'var'는 함수 단위
  - 'let'은 블록 단위
  - 스코프 내부에 이름 중복 선언일 경우 가까운 블록의 값을 사용
  - Hoisting: 'let' vs 'var' --- 위에 정리

=======================================================================================
#4 Javascript 응용(step 3)

* 함수
  - 다른 프로그래밍 언어와의 다른 점은 리턴 확인이 안된다.
  - 함수 종류
    1) 익명 함수: 이름을 붙이지 않고 함수 정의
      - 전역으로 호출, 나를 호출한(= this) 함수가 전역이다.
      ex) 익명 함수 구조
        let <변수 이름> = function () { };    // 익명 함수를 변수에 할당
        <변수 이름>();    // 함수 코드 실행

    2) 선언적 함수: 이름을 붙여 함수 정의
      ex) 선언적 함수 구조
        function <함수 이름>(<매개 변수>){
          <함수 코드>
          return <리턴 값>
        }
        <함수 이름>(<인자>)   // 함수 코드 실행

    3) 화살표 함수(ECMA6): 화살표를 사용하여 함수 정의
      - 권장한다.
      - 영역(블록) 내에서 호출, 나를 호출한(= this) 함수가 바로 밖의 객체 영역이다.
      ex) 화살표 함수 구조
        let <변수 이름> = () => { };    // 화살표 함수를 변수에 할당
        <변수 이름>();      // 함수 코드 실행

  - 익명 함수, 화살표 함수를 변수에 저장하지 않는 경우에는 재사용이 불가능하다.
  - return문이 없다면 undefined가 된다 -> undefined를 검사해준다.
  - 콜백(call-back) 함수: 매개 변수 형태로 전달하는 함수(이벤트 식으로 실행)
  - 표준 내장 함수 종류
    1) 파싱 함수
      - parseInt()함수: int로 자료형을 바꿔준다
      - parseFloat() 함수: float으로 자료형을 바꿔준다
    2) 타이머 함수
      - setTimeout(함수, 시간): 특정 시간 후에 콜백 함수를 실행
      - setInterval(함수, 시간): 특정 시간마다 콜백 함수를 실행
      - clearInterval(<변수 이름>): setInterval 함수 등록을 삭제해준다.
        ex) 타이머 함수 등록 해제
          let id = setInterval(()=>{
            console.log("1초마다 출력");
          }, 1000);

          setTimeout(()=>{
            clearInterval(id);
            console.log("1초마다 출력 이벤트 등록 해제");
          }, 3000);

  - 함수가 값으로 쓰일 때, 일반 변수 사용처럼 덮어쓰기가 가능하다(재사용은 권장하지 않는다)

* 객체
  - 접근 방법 차이(배열은 'index', 객체는 'key')
    ex) 객체 접근 방법 2 가지
      객체["key"];      // 문자열 접근
      객체.key;       // key 접근

  - 정의 방법 차이(배열은 '[]', 객체는 '{}')
  - 이름 차이(배열은 '요소(Element)', 객체는 '속성(Property)')
  - 메소드: 객체의 속성 중 자료형이 함수인 속성(객체 안의 함수)
  - for...in으로 순회한다(enumerables)
    ex) 객체 순회
      for(let key in object){
        console.log(`${key}: ${object[key]}`)
      }
  - 객체 생성 방법 종류
    1) 객체 정의시 생성
      let products = [
        {name: '바나나', price: 1200, print: function(){console.log(`${this.name}, ${this.price}`)}, },
        {name: '사과', price: 2000, print: function(){console.log(`${this.name}, ${this.price}`)}, },
        {name: '배', price: 3000, print: function(){console.log(`${this.name}, ${this.price}`)}, },
      ];

    2) 생성자와 프로토타입: 대문자로 시작하는 이름 사용
      function Product(name, price){
        this.name = name;
        this.price = price;     // 리턴이 없다, new로 객체 리턴
      }
      Product.prototype.print = function(){     // 함수를 속성으로 만듬, 생성자가 없을 경우 사용 불가
        console.log(`${this.name} ${this.price}`);
      }
      let 변수명 = new Product("바나나", 1200);    // new가 있기 때문에 undefined 리턴 X
  
  - "아예 값이 없는 상태"를 구분할 때 'null' 활용, undefined도 null 값과 같다('==')
  - 객체 리터럴 표현
    ex)
      let es = "es";
      const newObject = {
        sayJS(){
          console.log("JS");
        },
        [es + 6]: "ES6",
      };
      newObject.sayJS();
      console.log(newObject.es6);   // ES6

  - 구조분해 할당: 객체 안의 속성, 배열 안의 요소를 변수명으로 사용 가능
    1) const{ 변수 } = 객체;
    ex) 객체 구조분해 할당
      const candyMachine = {
        status: {
          name: "상태",
          count: 4,
        },
        getCandy(){
          return 1;
        }
      }
      const {getCandy, status: { name }} = candyMachine;      // 구조분해 할당

    2) const[ 변수 ] = 배열;
    ex) 배열 구조분해 할당
      const array = ["nodejs", {}, 10, true];
      const [node, obj, , bool] = array;      // 구조분해 할당, 값을 버릴 경우 빈칸 처리(배열은 순서가 있기 때문)

  - Class 문법 사용(ECMA6 부터) --- ES6 전에는 복잡
      1) constructor: 생성자
      2) extends: 상속 가능
      3) super와 this: 부모 참조자와 현재(자식) 참조자
      4) static: 클래스 내의 전역 변수 or 함수
    모두 사용 가능

=======================================================================================
#5 Javascript 응용(step 4)

* 기본 자료형과 객체 자료형
  - 기본 자료형: 메소드를 사용할 때, 임시로 객체 변환
  ex) 기본 자료형의 초기화 타입
    let n = 273;
    let s = "안녕하세요";
    let b = true;
    console.log(typeof n);     // number 출력
    console.log(typeof s);     // string
    console.log(typeof b);    // boolean

  - 객체 자료형
  ex) 객체 자료형의 초기화 타입
    let n = new Number(273);
    let s = new String("안녕하세요");
    let b = new Boolean(true);
    console.log(typeof n);     // object 출력
    console.log(typeof s);     // object
    console.log(typeof b);    // object

  - 기본 자료형은 객체가 아니므로 속성과 메소드 추가는 불가(프로토타입으로 전역은 가능)

* Number 객체
  - 숫자를 표현할 때 사용
  - 메소드 종류
    1) toExponential(): 숫자를 지수 표시로 나타낸 문자열 리턴
    2) toFixed(): 고정소수점 표시로 나타낸 문자열 리턴
    3) toPrecision(): 길이에 따라 유동적으로 지수 or 고정소수점 표시로 나타낸 문자열 리턴
  
  - 생성자 함수로 사용가능한 속성들
    1) MAX_VALUE: Number로 표시할 수 있는 최댓값, Number.MAX_VALUE
    2) MIN_VALUE: Number로 표시할 수 있는 최솟값, Number.MIN_VALUE
    3) NaN: 나타낼 수 없는 숫자
    4) POSITIVE_INFINITY: 양의 무한대 숫자
    5) NEGATIVE_INFINITY: 음의 무한대 숫자

* String 객체
  - 문자열
  - 속성 종류
    1) length

  - 메소드 종류(리턴 값으로 반환, 원본 수정X)
    1) charAt(position): position에 위치하는 문자 리턴
    2) charCodeAt(position): position에 위치하는 문자의 유니코드 번호 리턴
    3) concat(args): 문자열을 이어서 리턴
    4) indexOf(searchString, position): 특정 문자열이 있는지 확인, 위치를 리턴(없으면 -1)
    5) lastIndexOf(searchString, position)
    6) split(separator, limit): 특정한 기호를 기반으로 문자열을 분해하여 리턴
    7) slice(start end): 특정 위치의 문자열을 추출해 리턴
    8) substr(start, count): start부터 count까지 문자열 잘라서 리턴
    9) substring(start, end): start ~ end까지 문자열 잘라서 리턴
    10) toLowerCase(): 문자열을 소문자로 바꿔 리턴
    11) toUpperCase(): 문자열을 대문자로 바꿔 리턴
    12) match(regExp): 문자열에 "regExp"가 있는지 확인
    - "regExp" 매개변수는 정규 표현식(규칙을 정해서 인자로 넘김)

* Date 객체
  - new Date(): 현재 시간으로 Date 객체를 생성
  - 주의: Month는 0부터 시작, 0은 1월 / 11은 12월
  - 메소드 종류
    1) get...(): 조회(FullYear, Month, Day, Hors, Minutes, Seconds)
    2) set...(): 설정(FullYear, Month, Day, Hors, Minutes, Seconds)

* Array 객체(중요!, JSON 제어)
  - 메소드 종류('*'은 자신을 변화시킴)
    1) concat(): 배열의 요소 함쳐서 리턴
    2) join(): 배열 안의 모든 요소를 문자열로 리턴
    3)*pop(): 마지막 요소 제거
    4)*push(): 마지막 부분 새로운 요소 추가
    5)*reverse(): 요소 순서 뒤집기
    6) slice(): 요소의 지정한 부분 리턴
    7)*sort(): 요소를 정렬
      ex) 정렬 조건 정하기
        array.sort((itemA, itemB) =>{
          return itemA.value - itemB.value;     // 오름차순(-1값일 경우 뒤가 더 크다)
        });
    8)*splice(): 지정한 부분 삭제 후 삭제한 요소 리턴
    9) forEach(): 배열의 요소를 하나씩 뽑아서 반복문을 돌린다.
    10) map(): 콜백 함수에서 리턴하는 것을 기반으로 새로운 배열 생성 후 리턴
      ex)
        let output = array.map((item, index) => {
          return index * item;
        });

    11) filter(): 콜백 함수에서 true로 리턴되는 것만으로 새로운 배열 생성 후 리턴
      ex)
        let output = array.filter((item, index) => {
          return item % 2==0;
        });

* Underscore.js 라이브러리(2009년 발표)
  - 설치: npm install underscore
  - 사용: const _ = require("underscore");
  - 메소드 종류
    1) _.sortBy()
    ...) ...
  - 메소드가 더 추가된 Lodash가 2012년 발표
  - require할 경우에 배포할 사이즈가 커진다.
  - Javascript Native 함수로 추가하는 경향으로 성능 상으로 안쓰는 것을 권장

* JSON 객체
  - Javascript 객체를 사용한 데이터 표현 방법
    ex) 기본 형태
      {
        "name": "고구마",    // 문자열은 무조건 끈따옴표로, key도 큰따옴표로 만듦
        "price": "1000",     // 숫자, 문자열 불 자료형만 사용
      }
  - 메소드 종류: 통신할 때 필요
    1) JSON.stringify(<객체>, <변환 함수>, <공백 개수>): Javascript 객체를 문자열로 만듦.
    2) JSON.parse(문자열): 문자열을 Javascript 객체로 파싱.

* Promise(ES6부터)
  - "Call-back hell" 문제에 대한 해결책
  - 내용이 실행 되었지만 결과는 아직 반환하지 않은 객체
  - 비동기 연산이 종료된 이후, 결과값이나 실패의 이유를 처리하기 위한 함수를 연결
  - State 종류
    1) 대기(pending)
    2) 이행(fulfilled)
    3) 거부(rejected)
  - promise 사용
    ex)
      const promise = new Promise((resolve, reject)=>{    // 매개변수는 성공과 실패 함수
        if(condition){
          resolve("성공");
        }else{
          reject("실패");
        }
      });

      // 다른 코드 추가 가능

      promise
        .then((message) =>{   // then의 리턴값은 또다른 promise 객체
          console.log(message);     // 성공(resolve)시 실행
        })
        .catch((error){
          console.error(error);     // 실패(reject)시 실행
        })
        .finally(()=>{
          console.log("끝나고 무조건 실행");    // 실행 끝나고 마지막 무조건 실행
        });

  - Promise chaining: then의 리턴값은 또다른 Promise 객체이므로 이를 연달아 사용 가능
  - return 값이 없을 경우에는 undefined
  - 객체를 변수로 저장하여 ".then"으로 여러 개의 핸들러 함수를 만들 수 있다.
  - Promise.all(배열): 여러 개의 프로미스를 동시에 실행
    ex)
      const promise1 = Promise.resolve("성공");
      const promise2 = Promise.resolve("성공");
      Promise.all([promise1, promise2])
        .then((result) => {
          console.log(result);
        })
        .catch((error)=>{   // 하나라도 실패할 경우 catch로 감, allSettled로 추려내기 가능
          console.error(error);
        });

* Async / await
  - 프로미스 패턴 코드를 Async / await로 축약 가능
  - 사용: 
    1) async 함수()
    2) 변수 = await 프로미스(결과값) or 값; 
    ex)
      async function A(vA){   // 화살표 함수로도 가능
        try{      // 각각의 프로미스 에러 처리를 위해 try-catch로 감싸야한다.
          let v1 = await vA.A1({});
        }catch(error){
          console.error(error);
        }
        try{
          let v2 = await vA.A2({});
        }catch(error){
          console.error(error);
        }
      }

  - async 화살표 함수로도 가능하다.
    ex) async () => {}
  - Async 함수는 항상 promise를 반환: then or await을 붙일 수 있다.
  - for await(변수 of 프로미스 배열)로 프로미스가 변수에 할당되어 나온다, Only async 함수 안에서 가능

=======================================================================================
#6 Node.js 기본

* REPL(Read, Evaluate, Print, Loop)
  - Javascript는 (Python과 같이) Script언어이므로 즉석에서 코드를 실행
  - Read, Evaluate, Print가 Loop를 돌면서 진행한다.
  - 프롬프트가 '>' 모양으로 바뀌면 코드 입력 -> 입력한 값의 결과값이 바로 출력

* JS 파일 실행(.js)
  - [node <.js>]로 실행

* 모듈(Module)
  - 특정한 기능을 하는 함수나 변수들 집합
  - 여러 프로그램에서 재사용 가능
  - module.exports로 모듈 값을 지정하고 require(URL)로 모듈 내용을 가져온다.
    ex 1) 모듈 지정(var.js)
      const odd = 3;
      const even = 2;

      module.exports = {odd, even};   // ES2015 이전
      export default {odd, even};     // ES2015 에서는 export default로 바뀜(Typescript)

    ex 2) 모듈 사용(func.js)
      const {odd, even} = require("./var"); // ES2015 이전
      // import {odd, even} from "./var";   // ES2015 에서는 import-from으로 바뀜(Typescript)

      function checkOddOrEven(num){
        if(num % 2) return odd;
        return even;
      }

* 노드 내장 객체
  1) global 객체
    - 노드의 전역 객체(브라우저의 window=DOM 객체)
    - 모든 파일에서 접근 가능
    - window 객체처럼 생략 가능
    - global 속성: global 속성에 값을 대입하면 다른 파일에서도 사용 가능

  2) console 객체(디버깅용)
    - console.time(문자열 레이블), console.timeEnd(문자열 레이블): 시간 로깅
      ex) "시간 측정" 레이블로 시간 측정
        console.time("시간 측정");
        for(int i=0; i<100000; i++);
        console.timeEnd("시간 측정");

    - console.error(): 에러 로깅
    - console.log(): 일반 로깅
    - console.dir(): 객체 로깅
    - console.trace(): 호출 스택(에러 위치) 로깅

  3) 타이머 메소드
    - setTimeout(콜백 함수, 밀리초), clearTimeout(아이디): 밀리초 이후에 콜백 함수 실행, 취소
    - setInterval(콜백 함수, 밀리초), clearInterval(아이디): 밀리초 마다 콜백 함수 반복 실행, 취소
    - setImmediate(콜백 함수), clearImmediate(아이디): 즉시 콜백 함수 실행, 취소

  4) __filename, __dirname: 현재 파일 경로, 현재 디렉토리 경로
    - Window 경우, '\'로 사용
    - Mac, Linux 경우, '/'로 사용
    -> path 모듈로 경로 처리하여 해결

  5) module, exports
    - exports는 module.exports를 참조한다.
      ex) 모듈 지정
      const odd = 3;
      const even = 4;
      module.exports = {odd, even};

      // 위와 동일한 모듈 지정
      // exports.odd = 3;
      // exports.even = 4;

  6) this 키워드
    - 최상위 스코프의 this는 module.exports를 가리킴(in node.js)
    - 함수 선언문 내부의 this는 global(전역) 객체를 가리킴(in node.js)

  7) require 함수
    - require.main: 노드 실행 시 첫 모듈을 가리킴(이 파일이 처음으로 실행하는 프로그램 확인 가능)
    - require.cache: 첫 번째로 require한 모듈에 대한 캐싱 정보가 들어있다.(갱신된 JSON 읽기 문제)
    - Javascript는 대소문자 구별하기 때문에 같은 파일을 읽으면 여러 파일로 캐싱한다.
    - 순환 참조 상황을 막기 위해 처음 참조 객체는 빈 객체를 넣는다.

  8) process 객체
    - 현재 실행중인 노드 프로세스에 대한 정보를 담고있다.
    - 속성
    1) process.version: 설치된 노드 버전
    2) process.arch: 프로세서 아키텍처 정보("x64", "arm", "ia32")
    3) process.platform: OS 플랫폼 정보
    4) process.pid: 현재 프로세스 아이디
    5) process.execPath: 노드의 경로
    6) *process.env: 시스템 환경 변수 정보, 비밀키 보관 용도
      ex) 노드 실행 시 영향을 미치는 일부 환경 변수
        NODE_OPTIONS = --max-old-space-size=8192    // 노드가 사용할 수 있는 메모리 지정
        UV_THREADPOOL_SIZE = 8      // 스레드풀 크기 지정

    - 메소드
    1) process.uptime(): 프로세스가 시작된 후 흐른 시간(단위: 초)
    2) process.cwd(): 현재 프로세스 실행 위치
    3) process.cpuUsage(): 현재 CPU 사용량
    4) *process.nextTick(콜백 함수): 다른 콜백 함수들보다 우선적으로 처리
      - 우선순위: setImmediate < promise < nextTick
      - 너무 남용하면 다른 콜백 함수들 실행이 늦어진다(필요한 경우에만 사용)
    5) *process.exit(코드): 현재의 프로세스를 멈춤
      - 코드가 없거나 0일 경우 정상 종료.
      - 이외의 코드는 비정상 종료를 의미.

* 노드 내장 모듈: require할 때, 경로 대신 이름만 적어 사용
  1) OS
    - 운영체제의 정보를 담고 있다.
    - 메소드
      1) os.homedir(): 홈 디렉토리 경로
      2) os.hostname(): 컴퓨터의 이름
      3) os.uptime(): 운영체제 부팅 이후 흐른 시간(초)
      4) os.type(): 운영체제 종류
      5) os.tmpdir(): 임시 파일 저장 경로
      6) os.cpus(): 컴퓨터의 코어 정보
      7) os.totalmem(): 전체 메모리 용량
      8) os.freemem(): 사용 가능한 메모리(RAM)
      ...) ...
  
  2) **path
    - 폴더, 파일의 경로를 쉽게 조작하도록 도와주는 모듈(string으로만)
    - 운영체제별 경로 구분자가 달라 유용하게 쓰인다(Windows: '\' or POSIX[Linux, Mac]: '/')
    - 상대 경로: 현재는 '.', 한 단계 상위 경로는 '..'
    - 메소드
      1) path.delimiter: 환경 변수의 구분자 --- window: 세미콜론(';'), POSIX: 콜론(':')
      2) path.extname(경로): 파일의 확장자
      3) path.parse(경로): 
      4) path.normalize(경로): '\', '/'를 혼용하거나 중복 사용 실수할 경우 해결해주는 메소드
      5) path.isAbsolute(경로): 절대 경로('/'로 시작)인지(true), 상대 경로인지(false)
      6) path.relative(기준 경로, 비교 경로): 기준 경로부터 비교 경로까지 상대 경로 출력
      7) path.resolve(경로, ...): 절대 경로로 합쳐준다(만약 '/'를 만나면 루트로 인식하여 이전 경로들 무시)
        ex) path.resolve("/a", "/b", "c");  // 결과: "/a" -> "/b" -> "./b/c"

      8) path.join(경로, ...): 상대 경로로 합쳐준다('/'를 만나도 계속 합쳐줌)
        ex) path.join("/a", "/b", "c");     // 결과: "./a/b/c"
    
    - ['\\' vs '\']: '\'는 윈도 경로 구분자, '\\'는 Javascript 문자열 안에서 사용('\'로 이스케이프 해줌)
    - 객체
      1) path.posix: Window에서 POSIX path를 쓰고 싶을 때 사용
      2) path.win32: POSIX에서 Window path를 쓰고 싶을 때 사용

  3) **url
    - 인터넷 주소를 쉽게 조작하도록 도와주는 모듈
    - url 처리 방식
        ex) https: // user:pass @ sub.host.com: 8080 /p/a/t/h ? query=string #hash
        
      1) 기존 Node 방식: auth 속성 존재, query 존재
        ex) url.parse("URL");

      2) *WHATWG 방식: username과 password 문자열 속성 존재, searchParams 존재
        ex) new URL("URL");

      - 메소드
        1) url.parse(주소)
          - 주소를 분해(기존 Node 방식)
        2) url.format(객체)
          - 분해되었던 url 객체(WHATWG or 기존 Node 방식)를 원래 상태로 조립
    
  4) searchParams(for. WHATWG 방식)
    - WHATWG 방식에서 쿼리스트링(search) 부분 처리를 도와주는 객체
    - 메소드
      1) getAll(키): 키에 해당하는 모든 값들 가져옴
      2) get(키): 키에 해당하는 첫 번째 값만 가져옴
      3) has(키): 해당 키가 있는지 검사
      4) append(키, 값): 해당 키 추가(중복일 때도 하나 더 추가)
      5) set(키, 값): 값들을 모두 지우고 새로 추가
      6) delete(키): 해당 키 제거
      7) toString(): searchParams 객체를 다시 문자열로 만듬

  5) querystring(for. Node Legacy 방식)
    - 기존 노드 방식의 URL에서 query조작을 쉽게 도와줌
    - 메소드
      1) querystring.parse(쿼리): url의 query 부분을 Javascript 객체로 분해
      2) querystring.stringify(객체): 분해된 query 객체를 문자열로 다시 조립

  6) crypto(for. 단방향 암호화) --- ex. 웹 사이트의 사용자 ID, Password
    - 암호화는 가능하지만 복호화(해독) 불가능 --- 복원할 필요가 없다.
    - 해시 기법: 문자열을 고정된 길이의 다른 문자열로 바꿈
    - 메소드
      1) createHash(알고리즘)
        - 해시 알고리즘 종류
          1) md5: 취약
          2) sha1: 취약
          3) sha256
          4) *sha512: 현재

      2) update(문자열): 변환할 문자열을 넣어줌
      3) digest(인코딩): 인코딩할 알고리즘을 넣어줌(보통 base64)
  
  7) pdkdf2(for. 단방향 암호화)
    - 컴퓨터 발달로 기존 암호화 알고리즘이 위협 당해 출현
    - "salt"와 "반복 횟수"를 추가하여 보안 강화
    - Node에서 지원

  8) crypto(for. 양방향 암호화) --- ex. 채팅 등
    - key를 사용
    - 암호화 가능, 복호화 가능 --- 둘 다 같은 key
    - 메소드
      1) crypto.createCipheriv(알고리즘, 키, 초기화벡터)
      2) cipher.update(문자열, 인코딩, 출력 인코딩): 암호화, 인코딩은 utf8, 암호는 base64를 많이 사용
      3) decipher.update(문자열, 인코딩, 출력 인코딩): 복호화

  9) util
    - 각종 편의 기능을 모아둠
    1) deprecated
      - 첫 번째 인자로 넣은 함수를 사용한 경우, 두 번째 인자로 경고 메시지를 넣어 출력
      - 배포 입장에서 기존 기능을 조만간 사라지거나 변경할 때 알려줄 수 있다.
      ex) util.deprecate(함수, 메시지);

    2) promisify
      - 콜백 패턴을 프로미스 패턴으로 변경, async/await 사용 가능
      ex) util.promisify(콜백 함수)

      - 프로미스 패턴을 콜백 패턴으로 변경
      ex) util.callbackify(콜백 함수)

  10) *worker_threads
    - Node에서 멀티 스레드(병렬 처리) 방식으로 작업 가능
    - Node에서 스레드는 독립되어 메모리 공간을 공유하지 않는다(코드 공간 공유 X)
    - Node에서 "Race condition"이 발생하지 않음
    - 메소드
      1) isMainThread
        - 현재 코드가 메인 스레드에서 실행되는지, 워커 스레드에서 실행되는지 *구분*
        - new Worker(__filename): 현재 파일에 대해 워커 스레드에게 일을 넘김

      2) worker.postMessage("message")
        - 워커에게 데이터 보냄(부모 기준)
      3) worker.on("message", 콜백 함수)
        - 워커로부터 데이터를 받음(부모 기준)
      4) parentPort.postMessage("message")
        - 부모에게 데이터 보냄(워커 기준)
      5) parentPort.on("message", 콜백 함수)
        - 부모로부터 데이터를 받음(워커 기준)

  ex 1) 워커 스레드 1개
    const{    // 워커 스레드 사용
      Worker, isMainThread, parentPort,
    } = require("worker_threads");

    if(isMainThread){   // 부모일 때
      const worker = new Worker(__filename);
      worker.on("message", message => console.log("from worker", message));   // 메시지 리스너 등록
      worker.on("exit", () => console.log("worker exit"));    // 메시지 리스너 등록
      worker.postMessage("ping");   // 메시지 전송
    } else{   // 워커일 때
      parentPort.on("message", (value) => {   // 메시지 리스너 등록
        console.log("from parent", value);
        parentPort.postMessage("pong");   // 메시지 전송
        parentPort.close();     // 워커 스레드 종료, 자동으로 parent에게 exit 메시지 전송
      });
    }

  ex 2) 워커 스레드 2개(Set 이용)
    const{
      Worker, isMainThread, parentPort, workerData
    } = require("worker_threads");

    if(isMainThread){     // 부모일 때
      const threads = new Set();
      threads.add(new Worker(__filename, {    // new Worker 호출하는 수만큼 워커 스레드 생성
        workerData: {start: 1},
      }));
      threads.add(new Worker(__filename, {    // 동일한 파일로 실행되는 스레드를 만든다.
        workerData: {start: 2},
      }));
      for(let worker of threads){   // worker는 워커 스레드
        worker.on("message", message => console.log("from worker", message));   // 해당 worker의 메시지 리스너 등록
        worker.on("exit", () => {     // 해당 worker의 종료 리스너 등록
          threads.delete(worker);
          if(threads.size===0){
            console.log("job done");
          }
        });
      }
    } else{   // 워커일 때
      const data = workerData;
      parentPort.postMessage(data.start+100);
    }
  
    ex 3) 멀티 스레드 소수 찾기 예제
      const{Worker, isMainThread, parentPort, workerData} = require("worker_threads");

      const min = 2;
      let primes = [];      // 각 스레드는 공유하지 않는다(스레드마다 따로 생성)
      
      // 소수 찾기 함수
      funtion findPrimes(start, range){
        let isPrime = ture;
        let end = start + range;
        for(let i = start; i < end; i++){
          for(let j = min; j < Math.sqrt(end); j++){
            if(i !== j && i % j === 0){
              isPrime = false;
              break;
            }
          }
          if(isPrime){
            primes.push(i);
          }
          isPrime = true;
        }
      }

      // Multi-threads processing
      if(isMainThread){       // 부모일 때
        const max = 10000000;
        const threadCount = 8;      // 8개의 스레드 생성
        const threads = new Set();      // 스레드 보관하는 Set 컨테이너
        const range = Math.ceil((max-min) / threadCount);     // 범위를 8개로 나눔
        let start = min;
        consoel.time("prime");      // 시간 측정 시작
        for(let i = 0; i < threadCount-1; i++){   // (스레드 7개)에 대해서
          const wStart = start;   // 처음 start
          threads.add(new Worker(__filename, {    // 스레드 생성
            workerData: {start: wStart, range}  // 디폴트 시작, 범위 초기화 --- 나중에 시작만 다시 할당
          }));
          start += range;   // 시작을 다시 할당
        }
        threads.add(new Worker(__filename, {    // 나머지 자투리에 대해서 (스레드 1개) 생성
          workerData: {start, range: (max-min+1) % threadCount + range}
        }));
        for(let worker of threads){
          worker.on("error", (err) => {     // 에러 발생할 경우의 리스너를 등록
            throw errr;
          });
          worker.on("exit", () => {     // 해당 스레드 작업 완료
            threads.delete(worker);     // Set 컨테이너에 워커 스레드 삭제
            if(threads.size() === 0){
              console.timeEnd("prime");
              console.log(primes.length);   // 소수 갯수
            }
          });
          worker.on("message", (msg) => {
            primes = primes.concat(msg);    // 메인 스레드가 worker로부터 가져온 primes를 concat해준다(무작위 순서)
          });
        }
      } else{
        findPrimes(workerData.start, workerData.range);   // 워커 스레드가 하는 일
        parentPort.postMessage(primes);   // 메시지로 각 스레드의 primes(독립 공간)를 보내줌
      }

  11) child_process
    - Node에서 다른 프로그램을 실행하고 싶을 때
    - 새로운 프로세스로 명령을 수행
    - exec vs spawn: exec는 단순한 출력, spawn은 복잡한 출력
    ex 1) dir(or ls)을 노드로 실행 - 간단한 출력(exec)
      const exec = require("child_process").exec;

      let process = exec("dir");

      process.stdout.on("data", function(data){
        console.log(data.toString());
      });   // 실행 결과

      process.stderr.on("data", function(data){
        console.error(data.toString());
      });   // 실행 에러

    ex 2) 파이썬3 프로그램 실행 - 복잡한 출력(spawn)
      const spawn = require("child_process").spawn;

      let process = spawn("python", ["test.py"]);

      process.stdout.on("data", function(data){
        console.log(data.toString());
      });   // 실행 결과

      process.stderr.on("data", function(data){
        console.error(data.toString());
      });   // 실행 에러

  12) 기타 모듈들
    - *assert: 값을 비교하여 프로그램이 제대로 동작하는지 테스트
    - *dns: 도메인 이름에 대한 IP 주소를 얻음
    - net: HTTP보다 TCP나 IPC 통신을 할 때 사용
    - string_decoder: 버퍼 데이터를 문자열로 바꾸는 데 사용
    - tls: TLS와 SSL에 관련된 작업을 할 때 사용
    - tty: 터미널과 관련된 작업을 할 때 사용
    - dgram: UDP와 관련된 작업을 할 때 사용
    - v8: V8 엔진에 직접 접근할 때 사용
    - vm: 가상 머신에 직접 접근할 때 사용

* 파일 시스템
  - fs: 파일 시스템에 접근하는 모듈
  - 파일/폴더 생성, 삭제, 읽기, 쓰기 가능
  - 웹 브라우저는 파일 접근이 제한, Node는 권한이 있음
  - 파일을 읽을 때, 프로미스 방식으로 사용 가능(콜백 방식보다 권장)
  - 메소드
    1) readFile(경로): 파일을 읽는다.
    2) writeFile(경로, 문자열): 파일을 쓴다.

  - 동기, 비동기 메소드("Sync"가 후미에 붙은 함수)
    : Node의 대부분 내장 모듈 메소드는 비동기 방식
    : 코드의 순서와 실행 순서가 다르다.
    : 일부는 동기 방식으로 사용 가능
    : (동기, 블로킹), (비동기, 논 블로킹)으로 Node 실행
    : 파일을 읽을 때, 동기 메소드는 "Sync"가 붙는다.
    : 비동기 메소드로 순서 유지하려면 프로미스(or 콜백 함수)방식을 사용한다.

  - 버퍼(주로 받을 때) --- "모아서 처리"
    : 일정한 크기로 모아두는 데이터
    : 일정한 크기가 되면 한 번에 처리
    : "버퍼링"은 버퍼에 데이터가 찰 때까지 모으는 작업
    : Node 에서는 Buffer 객체가 내장됨
    : 속성
      1) length: 버퍼의 크기(byte 단위)
    : 메소드
      1) from(문자열): 문자열을 버퍼로 바꾼다
      2) toString(버퍼): 버퍼를 다시 문자열을 바꾼다
      3) concat(배열): 배열 안에 든 버퍼들을 하나로 합침
      4) alloc(바이트): 인자 없으면 빈 버퍼 생성, byte 인자로 해당 크기 버퍼 생성
      ex) 버퍼 사용
        let buffer = Buffer.from("버퍼로 바꾸기");
        console.log(buffer.toString());   // 버퍼 내용을 문자열로 읽기
        buffer2 = Buffer.alloc(5);    // 5 byte 크기 버퍼 생성
        buffer = Buffer.concat([buffer, buffer2]);      // 버퍼에 이어붙이기

  - 스트림(주로 전달할 때 + 버퍼 사용) --- "게속 처리"
    : 데이터의 흐름
    : 일정한 크기로 나눠서 여러 번에 걸쳐서 처리
    : 버퍼의 크기를 작게 만들어서 주기적으로 데이터를 전달
    : "스트리밍"은 일정한 크기의 데이터를 지속적으로 전달하는 작업, 받는 쪽은 "버퍼" 사용
    : 파일 읽기
      - fs.createReadStream(파일 경로, 옵션 객체)
      - highWaterMark 옵션은 버퍼 크기(byte 단위, Default: 64KB)
      - .on("data", 콜백 함수): chunk 전달 이벤트 리스너
      - .on("end", 콜백 함수): 전달 완료 이벤트 리스너
      - .on("error", 콜백 함수): 에러 발생 이벤트 리스너
      ex) 파일 읽는 스트림 사용
        const fs = require("fs");
        
        const readStream = fs.createReadStream("./readme.txt", {highWaterMark: 16});  // 16바이트 버퍼
        const data = [];

        readStream.on("data", (chunk) => {    // chunk 전달
          data.push(chunk);
          console.log("data", chunk, chunk.length);
        });

        readStream.on("end", () => {    // 전달 완료
          console.log("end", Buffer.concat(data).toString());
        });

        readStream.on("error", (err) => {   // 에러 발생
          console.log("error",  err);
        });
  
    : 파일 쓰기
      - fs.createWriteStream(파일 경로);
      - .write(문자열): Chunk 입력
      - .end(): 스트림 종료, finish 이벤트 발생
      ex) 파일 쓰기 스트림 사용
        const fs = require("fs");

        const writeStream = fs.createWriteStream("./writeme.txt");
        writeStream.on("finish", () => {    // 종료(finish) 리스너
          console.log("파일 쓰기 완료");
        });

        writeStream.write("글 쓰기");
        writeStream.write("입력");
        writeStream.end();      // finish 이벤트 발생

    : pipe를 사용하여 여러 개의 스트림을 이을 수 있다.
      ex) 파일을 압축한 후 복사하는 예제
      const zlib = require("zlib");   // 압축 내장 모듈
      const fs = require("fs");

      const readStream = fs.createReadStream("./readme.txt");   // 읽기 스트림
      const zlibStream = zlib.createGzip();   // 압축(.gz 파일 생성)
      const writeStream = fs.createWriteStream("./readme.txt.gz");    // 쓰기 스트림
      readStream.pipe(zlibStream).pipe(writeStream);  // 읽기에 압축 잇고 쓰기 잇기


  - 큰 파일을 만들 때는 createWriteStream으로 만들어야 메모리 문제가 생기지 않는다
  - 메모리 측면에서 "버퍼"보다 "스트림"을 사용하는 것이 좋다
  - 기타 fs 메소드
    1) fs.access(경로, 옵션, 콜백 함수): 폴더나 파일에 접근할 수 있는지 체크
      - 프로미스 형태로 처리
      - 옵션은 상수
        1) F_OK: 파일 존재 여부
        2) R_OK는 읽기 권한 여부
        3) W_OK는 쓰기 권한 여부
      - 만약, 권한이 없다면 에러 코드 "ENOENT"가 발생한다
    2) fs.mkdir(경로, 콜백 함수): 폴더를 만드는 메소드
    3) fs.open(경로, 옵션, 콜백 함수): 파일의 아이디(fd)를 가져오는 메소드
      - 파일이 없다면 파일을 생성한 뒤 그 아이디(fd)를 가져온다
      - 아이디(fd)를 사용하여 fs.read(), fs.write()로 읽거나 쓸 수 있다.
    4) fs.rename(기존 경로, 새 경로, 콜백 함수): 파일의 이름을 바꾸는 메소드
    5) fs.readdir(경로, 콜백): 폴더 안의 내용물 확인
    6) fs.unlink(경로, 콜백): 파일 지우기
      - 파일이 없다면 에러를 발생하므로 파일이 있는지 확인하고 진행
    7) fs.rmdir(경로, 콜백): 폴더 지우기
      - 폴더 안에 파일이 있다면 에러가 발생하므로 내부 파일 지우고 호출
    8) fs.copyFile(기존 경로, 복사할 경로): 파일을 복사한다
      - 프로미스 형태로 처리
    9) fs.watch(파일 경로, 콜백 함수): 파일이 수정이 되나 감시

* 스레드풀
  - fs, crypto, zlib 모듈의 메소드를 실행할 때는 백그라운드에서 동시에 실행됨
  - 스레드풀이 동시에 처리해준다.
  - 스레드풀을 직접 제어할 수 없고 개수 조절 가능(UV_THREADPOOL_SIZE)

* 이벤트
  - events 모듈로 custom 이벤트를 만들 수 있다.
  - 메소드
    1) on(이벤트명, 콜백 함수): 이벤트 이름과 콜백 함수를 연결해준다(Listening)
    2) addListener(이벤트명, 콜백 함수): on()과 동일
    3) removeAllListeners(이벤트명): 이벤트에 연결된 모든 이벤트 리스너 제거
    4) removeListener(이벤트명, 리스너): 이벤트에 연결된 리스너를 하나씩 제거
    5) emit(이벤트명): 이벤트명에 해당하는 이벤트를 호출하는 메소드
    6) once(이벤트명, 콜백 함수): 한 번만 실행되는 이벤트
    7) off(이벤트명, 콜백 함수): removeListener와 기능이 같다.
    8) listenerCount(이벤트명): 현재 리스너가 몇 개 연결돼 있는지

* 예외(Exception) 처리
  - 노드 스레드 멈춤 -> 노드는 싱글 스레드 -> 노드 프로세스 멈춤
  - try-catch로 에러가 발생할 만한 곳을 감싸서 예외 처리
  - 노드 비동기 메소드의 에러는 따로 처리할 필요 X(콜백 함수에서 매개 변수로 에러 객체 제공)
  - 프로미스 방식의 에러는 따로 처리할 필요 X(in 현재 버전)
  - 최후 수단: process.on("uncaughException", 콜백 함수)을 사용하여 기록용으로 사용
  - 강제 노드 프로세스 종료
    1) window: "taskkill /pid 프로세스아이디 /f"
    2) Mac/Linux: "kill -9 프로세스아이디"

=======================================================================================
#7 http 웹 서버

* 요청과 응답
  - 클라이언트가 서버로 요청(request)
  - 서버가 요청을 처리하고 클라이언트로 응답(response)

*  http 서버
  - write(문자열): 응답 내용 보냄
  - writeHead(연결 상태 코드, MIME 형식의 객체): 응답 헤더 보냄
  - end: 응답 마무리(내용 추가 가능)
  - listen(포트번호): 특정 포트에 연결

  ex 1) http 요청에 응답하는 서버
    const http = require("http");
    
    const server = http.createServer((req, res) => {
      res.writeHead(200, { "Content-Type": "text/html; charset=utf-8"});
      res.write("<h1>Hello Model</h1>");
      res.end("<p>Hello Server!</p>");
    });
    server.listen(8080);

    server.on("listening", () => {
      console.log("8080번 포트에서 서버 대기중!");
    });
    server.on("error", (error) => {
      console.error(error);
    });

  - "localhost:포트번호" or "http://127.0.0.1:포트번호" 로 접속
  - http의 포트 번호는 80, https의 포트 번호는 443, 다른 약속된 포트 번호가 있다.
  - 다른 포트로 DB or 다른 서버로 연결 가능
  - 포트 번호는 0~65535: 16-bit unsigned integer 자료형 사용
  - 한 번에 여러 개의 서버 실행 가능, 두 서버의 포트를 다르게 지정
    (같으면 EADDRINUSE 에러 발생, E Addr In Use)

  ex 2) 한 번에 여러 개의 서버 실행
    const http = require("http");

    http.createServer((req, res) => {
      res.writeHead(200, { "Content-Type": "test/html; charset=utf-8" });
      res.write("<h1>Hello Node!</h1>");
      res.end("<p>Hello Server 1</p>");
    }).listen(8080, () => {   // 8080번 서버 연결
      console.log("8080번 포트에서 서버 대기중!");
    })

    http.createServer((req, res) => {
      res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
      res.write("<h1>Hello Node!</h1>");
      res.end("<p>Hello Server 2</p>");
    }).listen(8081, () => {   // 8081번 서버 연결
      console.log("8081번 포트에서 서버 대기중!");
    })

  - write와 end에 문자열 넣는 것은 비효율적 -> (.html) 파일을 fs 모듈로 읽어서 전송

  ex 3) (.html)을 읽어서 전송
    const http = require("http");
    const fs = require("fs").promises;

    http.createServer(async (req, res) => {
      try{    // async, await의 에러 처리를 위해
        const data = await fs.readFile("./server2.html");   // 파일을 await으로 읽음
        res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });   // 파일을 정상적으로 읽으면 헤더를 보냄
        res.end(data);
      }catch(err){
        console.error(err);
        res.wirteHead(500, { "Content-Type": "text/plain; charset=utf-8" });
        res.end(err.message);
      }
    }).listen(8081, () => {
      console.log("8081번 포트에서 서버 대기중!");
    });

* REST API와 Routing
  - 서버에 요청을 보낼 때, 주소를 통해 요청의 내용을 표현한다.
  - REST API(Representational State Transfer)
    : 서버의 자원을 정의하고 자원에 대한 주소를 지정
    ex 1) /index.html -> index.html을 보내달라는 뜻
    ex 2) /user -> 사용자 정보에 관한 정보 요청
    ex 3) /post -> 게시글에 관련된 자원을 요청

  - HTTP 요청 메소드
    1) GET: 서버 자원을 가져오려고 할 때 사용
      ex) /index.html -> index.html을 보내달라는 요청
    2) POST: 서버에 자원을 새로 등록하고자 할 때 사용(애매할 때는 POST 메소드 사용)
      ex) 새로운 게시물 등록
    3) PUT: 서버의 자원을 요청하는 자원으로 치환하고자 할 때 사용
    4) PATCH: 서버 자원의 일부만 수정하고자 할 때 사용
    5) DELETE: 서버의 자원을 삭제하고자 할 때 사용

  - HTTP 프로토콜은 어떤 클라이언트든 HTTP 프로토콜로 소통이 가능하다(보안 위협)
  - DB는 안쪽에 숨겨야 보안을 강화할 수 있다(서버와 클라이언트 분리)

  - RESTful: REST API를 사용한 주소 체계를 이용하는 서버
    ex 1) GET/users -> 사용자 목록을 조회하는 요청
    ex 2) POST/users -> 사용자를 등록하는 요청
    ex 3) PUT/users/:사용자id -> 해당 id의 사용자 수정 요청
    ex 4) DELETE/users/:사용자id -> 해당 id의 사용자 제거 요청

    ex) REST 서버 구조
      const http = require("http");
      
      http.createServer(async (req, res) => {
        try{
          if(req.method === "GET"){     // GET 처리
            // 페이지를 요청하면 HTML 파일을 전송
            // JSON 형식으로 보내기 위해 JSON.stringify()
            // 그 외의 GET 요청은 CSS, JS 파일 요청에 대해 찾아서 응답하거나 404 NOT FOUND 에러 응답
          }else if(req.method === "POST"){    // POST 처리
            // 새로 등록 처리
            // req.on("data", 콜백 함수), req.on("end", 콜백 함수)로 처리
            // readStream과 함께 요청이 들어오면 JSON.parse()로 문자열에서 JSON 객체로 파싱
          }else if(req.method === "PUT"){     // PUT 처리
            // POST와 동일한 방식으로 처리
          }else if(req.method === "DELETE"){    // DELETE 처리
            // 주소에 들어 있는 키에 해당하는 사용자 제거
          }
          res.writeHead(404);     // 못찾음
          return res.end("NOT FOUND");
        }catch(err){
          // error 처리
          console.error(err);
          res.writeHead(500, { "Content-Type": "text/plain; charset=utf-8" });  // 500: error
          res.end(err.message);
        }
      }).listen(8082, () => {
        console.log("8082번 포트에서 서버 대기 중!");
      });

* Cookie
  - 요청은 누가 요청을 보냈는지 모른다(IP 주소와 브라우저 정도는 확인 가능)
    -> 로그인 구현 -> 쿠키와 세션 필요!
  - Cookie: 키 = 값의 쌍  ex) "mycookie=test"
  - 매 요청마다 서버에 동봉해서 보냄
  - 서버는 쿠키를 읽어 누구인지 파악한다.
  - writeHead()에 "Set-Cookie" 명령어를 추가하여 쿠키를 설정

  ex) Cookie 제공 서버
    const http = require("http");

    http.createServer((req, res) => {
      console.log(req.url, req.header.cookie);
      res.wirteHead(200, { "Set-Cookie": "mycookie=test" });    // "Set-Cookie" 명령어로 클라이언트에게 쿠키값 전송
      res.end("Hello Cookie");
    }).listen(8003, () => {
      console.log("8083번 포트에서 서버 대기 중!");
    });

  - req.headers.cookie에 쿠키가 문자열로 담겨있음
  - favicon.ico는 브라우저가 자동으로 보내는 요청
  - 쿠키는 부가적인 정보이므로 헤더(요청, 응답 정보 들어있음)에 저장

  ex) Cookie 식별 서버
    const http = require("http");
    const fs = require("fs").promises;
    const url = require("url");
    const qs = require("querystring");

    // 쿠키 문자열을 객체로 변환
    const parseCookies = (cookie = "") => {   // 매개 변수 cookie 문자열을 받음
      cookie
        .split(";")                 // ';'으로 나눔
        .map((v) => v.split("="))    // '='으로 나눔
        .reduce((acc, [k, v]) => {      // acc 객체에 key, value로 acc에 공백 없이(trim 함수) 저장
          acc[k.trim()] = decodeURIComponent(v);    // URI를 해독
          return acc;
        }, {});
    };
    
    http.createServer(async (req, res) => {
      const cookies = parseCookies(req.headers.cookie);     // 쿠키 파싱(없으면 빈 객체)
      
      if(req.url.startsWith("/login")){     // URL이 "/login" 으로 시작
        const {query} = url.parse(req.url);
        const {name} = qs.parse(query);   // 쿼리스트링을 name으로 저장
        const expires = new Date();
        expires.setMinutes(expirse.getMinutes() + 5);     // 쿠키 유효 시간을 현재 시간 + 5분(자동 로그아웃)

        res.writeHead(302, {      // 헤더(쿠키 포함) 전송 + 리다이렉션 상태 코드
          Location: "/",
          "Set-Cookie": `name=${encodeURIComponent(name)}; Expires=${expires.toGMTString()}; HttpOnly; Path=/`,
        });   // toGMTString()은 표준시(GMT)의 문자열로 변환
        res.end();
      } else if(cookies.name){    // 쿠키가 있는 경우(name이 있을 경우)
        res.writeHead(200, { "Content-Type": "text/plain; charset=utf-8"});
        res.end(`${cookies.name}님 안녕하세요`);    // 환영 인사
      } else{     // 쿠키가 없는 경우
        try{
          const data = await fs.readFile("./cookie2.html");
          res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
          res.end(data);      // 로그인 페이지(로그인 폼이 있는 .html 파일)을 전송(리다이렉션)
        } catch(err){
          res.writeHead(500, { "Content-Type": "text/plain; charset=utf-8"});
          res.end(err.message);
        }
      }
    }).listen(8084);

  - 쿠키 옵션("Set-Cookie")
    : "쿠키명=쿠키값"으로 설정
    1) "Expires=날짜": 날짜를 입력하여 만료 기한 설정
    2) "Max-age=초": 초를 입력하여 만료 기한을 설정(중복될 시, "Expires"보다 우선순위가 높음)
    3) "Domain=도메인명": 쿠키가 전송될 도메인 설정(디폴트는 현재 도메인)
    4) "Path=URL": 쿠키가 전송될 URL을 설정(디폴트는 '/'), 모든 URL에서 쿠키 전송 가능
    5) "Secure": 설정 시, HTTPS일 경우만 쿠키 전송
    6) "HttpOnly": 설정 시, Javascript에서 쿠키 접근 불가(쿠키 조작 방지 가능) --- 권장

  - 쿠키의 정보는 노출(스니핑)과 수정(조작)되는 위험이 있다. -> Session(세션) 사용

* Session
  - 쿠키의 위험성(노출, 수정)으로 인해 출현
  - 중요한 정보는 서버에서 관리하고 클라이언트에는 Session key만 제공
  - 서버에 Session으로 쓸 객체 생성 후, key를 만들어 속성명으로 사용
  - 속성 값에 정보를 저장하고 key를 클라이언트에 보냄

  ex) Session 서버 예시
    // require: http, fs, url, querystring 등
    
    // parseCookies() 함수 구현
    
    const session = {};       // Session으로 쓸 객체
    
    http.createServer(async (req, res) => {     // Session 서버
      const cookies = parseCookies(req.headers.cookie);   // 쿠키 파싱
      if(req.url.startsWith("/login")){      // 로그인 URL로 접속
        // 쿠키와 동일: query, name, expires

        const uniqueInt = Date.now();   // key를 현재 시간으로 사용(동시에 들어와도 "ms"로 구별)
        session[uniqueInt] = {
          name,
          expires,
        };
        res.writeHead(302, {      // 리다이렉션과 함께 헤더(쿠키 포함) 전송
          Location: "/",
          "Set-Cookie": `session=${uniqueInt}; Expires=${expires.toGMTString()}; HttpOnly; Path=/`,
        });
        res.end();
      } else if(cookies.session && session[cookies.session].expires > new Date()){
        // 연결됐다는 응답(response) 구성
      } else{
        try{
          // 다시 로그인하도록 리다이렉션 응답 구성
        } catch(err){
          // 서버에 대한 에러 응답 구성
        }
      }
    }).listen(8085);

  - 실제 서버는 Session을 직접 구현하지 말고 "express-session" 사용!

* http 상태 코드
  - 요청이 성공 or 실패를 알려줌
  - writeHead 메소드에 첫 번째 인수로 넣은 값
  - https://developer.mozilla.org/ko/docs/Web/HTTP/Status
    1) 2XX
      - 성공을 알리는 상태 코드
      - 200(성공), 201(작성됨)
    2) 3XX
      - 리다이렉션(다른 페이지로 이동)을 알리는 상태 코드
      - 301(영구 이동), 302(임시 이동)
    3) 4XX
      - 요청 자체에 오류가 있을 때의 상태 코드
      - 401(권한 없음), 403(금지됨), 404(찾을 수 없음)
    4) 5XX
      - 서버에서 오류가 생겼을 때 발생하는 상태 코드
      - 500(내부 서버 오류), 502(불량 게이트웨이), 503(서비스를 사용할 수 없음)


* https와 http2
  - https: 웹 서버에 SSL 암호화를 추가하는 모듈
  - 오고 가는 데이터를 암호화해서 중간에 다른 사람이 요청을 가로채더라도 내용 확인 불가
  - 현재는 https 적용 필수(개인 정보가 있는 곳은 특히)
  - http 서버를 https 서버로 만들기
    : 암호화를 위해 인증서를 발급받아 사용(무료 or 유료)
  - createServer의 첫 번째 인자로 인증서와 관련된 옵션 객체 추가
    : pem, cert, key 등 인증서를 구입할 때 얻을 수 있는 파일 추가

  ex) https 서버
    const https = require("https");     // https 모듈 추가
    const fs = require("fs");

    https.createServer({
      cert: fs.readFileSync("도메인 인증서 경로"),
      key: fs.readFileSync("도메인 비밀키 경로"),
      ca: [
        fs.readFileSync("상위 인증서 경로"),
        fs.readFileSync("상위 인증서 경로"),
      ],
    }, (req, res) =>{
      // 응답(response) 구성
    }).listen(443);       // https 프로토콜의 디폴트 포트

  - http2: SSL 암호화와 더불어 사용하는 최신 HTTP 프로토콜
  - "http2"는 Multiplexing으로 웹의 속도가 개선됨
    : Multiplexing은 동시에 여러 개의 request를 보내는 기술

  ex) http2 서버
    const http2 = require("http2");   // http2 모듈 추가
    const fs = require("fs");

    http2.createSecureServer({      // createSecureServer() 사용
      // https와 동일
    }, (req, res) => {
      // 응답(response) 구성
    }).listen(443);     // 인증서 사용하므로 https 프로토콜 디폴트 포트

* Cluster
  - cluster: 싱글 스레드인 Node를 CPU 코어를 모두 사용할 수 있게 해주는 모듈
  - 포트를 공유하는 Node 프로세스를 여러 개 실행 가능(원래는 포트를 공유하면 에러 발생)
  - 요청이 많이 들어왔을 때, 병렬로 실행된 서버의 개수만큼 요청 분산 -> 서버 부하 감소
  - Node는 보통 코어 하나만 사용하는데 코어 하나당 각 노드 프로세스를 배정할 수 있다.
  - 컴퓨터 자원(메모리, 세션) 공유는 불가능하다. -> "Redis"등의 별도 서버로 해결

  ex) 서버 클러스터링 --- worker_threads 구조와 유사하다.
    const cluster = require("cluster");
    const http = require("http");
    const numCPUs = require("os").cpus().length;    // CPU 코어 개수

    if(cluster.isMaster){     // 마스터 프로세스일 경우
      console.log(`마스터 프로세스 id: ${process.pid}`);
      for(let i=0; i<numCPUs; i++){   // CPU 개수만큼 워커를 생산
        cluster.fork();     // 프로세스 생성
      }
      cluster.on("exit", (worker, code, signal) => {      // 워커가 종료되었을 때
        console.log(`${worker.process.pid}번 워커 종료!`);
        console.log(`code: ${code} signal: ${signal}`);
      });
    } else{      // 워커들이 동일한 포트에서 대기
      http.createServer((req, res) => {
        // 응답(response) 구성
      }).listen(8086);
    }

=======================================================================================
#8 패키지 매니저

* NPM(Node Package Manager)
  - npm: 다른 사람들이 만든 소스 코드들을 모아둔 저장소
  - 남의 코드를 사용하여 프로그래밍 가능
  - 오픈 소스 생태계
  - 의존 관계: 패키지(npm에 업로드 된 Node 모듈)가 다른 패키지를 사용하는 관계
  - 버전별로 기능이 다를 수 있으므로 버전을 기록해야 한다.
  - package.json
    : 현재 프로젝트에 대한 정보, 사용 중인 패키지에 대한 정보를 담은 파일
    : [npm init]으로 생성
    : 속성들
      1) package name: 패키지 이름
        - package.json 파일 안에 name 속성에 저장
      2) version: 패키지 버전(npm의 버전은 엄격하게 관리됨, 호환성 문제)
      3) entry point: Javascript 실행 파일 진입점, "module.exports" 코드가 들어있다.
        - main 속성에 저장
      4) test command: 코드를 테스트할 때 입력할 명령어
        - test 속성에 저장
      5) git repository: 코드를 저장해둔 Git 저장소 주소
        - repository 속성에 저장
      6) keywords: npm 공식 홈페이지의 검색 키워드
        - keywords 속성에 저장
      7) license: 해당 패키지의 라이센스(저작권)

  - 실행
    : npm run <스크립트명>으로 "scripts"속성에 포함되는 스크립트명을 실행

  - 기타 명령어
    1) npm outdated
    2) npm uninstall
    3) npm search: 웹으로 ㄱ
    4) npm info <패키지명>: 웹으로
    --- for publish
    5) npm adduser
    6) npm whoami
    7) npm logout
    8) npm version <버전>
    9) npm deprecate <패키지명> <버전> <메시지>: 패키지를 설치할 때, 경고 메시지 띄우게 함
    10) npm publish: 패키지를 배포
    11) npm unpublish: 배포 중단(배포 후 N시간(24?) 내에만 가능, 배포 중단 문제가 생기기 때문)
    ...) "https://docs.npmjs.com" - "CLI Commands" 에서 확인

* 패키지
  - 설치: npm install <패키지명>
  - 여러 개 설치: npm install <패키지명 1> <패키지명 2> <패키지명 3>
  - package.json에 맞는 설치: 해당 폴더에서 콘솔에 npm install 입력
    ex) express 설치
      1. 터미널에 npm install express 입력
      2. package.json에 기록됨(dependencies에 express의 이름과 버전 추가됨)
      3. node_modules 폴더 생성
        -> express 외에도 express와 의존 관계 있는 패키지들이 모두 설치됨
      4. package-lock.json도 생성됨(패키지 간 의존 관계를 명확하게 표시)
  
  - 개발용 패키지
    : 배포(Release)할 때, 포함되지 않는 패키지
    : 개발(Debug)할 때만 사용
    : npm install --save-dev <패키지명>
    : package.json파일 안에 devDependencies에 추가됨
    
    ex) nodemon 개발용 설치
      npm install --save-dev nodemon
      : nodemon은 프로덕션 빌드할 때 포함되지 않음
  
  - 전역(글로벌) 패키지
    : 모든 프로젝트와 콘솔에서 패키지를 사용 가능
    : npm install --global <패키지명>
    : 전역으로 설치하면 다른 프로젝트 패키지에 영향을 끼칠 수 있다.
    : npx로 전역 설치 없이 전역으로 사용 가능(임시 설치)

* 패키지 버전
  - Node 에서는 배포를 할 때 항상 버전을 올려야 한다.
  - SemVer(유의적 버저닝): Major.Minor.Patch, ex) 1.0.3, 2.2.4
    1) Major(주 버전): 하위 버전과 호환되지 않은 수정 사항
    2) Minor(부 버전): 하위 버전과 호환되는 수정 사항
    3) Patch(수 버전): 기능에 버그를 해결했을 때 올림, 간단한 버그 수정
  
  - 버전 앞에 기호 사용
    1) '^': 패키지 업데이트 시, Minor 버전까지만 업데이트
      ex) ^1.1.1: 2.0.0 버전 업데이트가 안됨
    2) '~': 패키지 업데이트 시, patch 버전까지만 업데이트
      ex) ~1.1.1: 1.2.0 버전 업데이트가 안됨
    3) >=, <=, >, <: 이상, 이하, 초과, 미만으로 업데이트 제한을 설정
    4) @latest: 최신을 의미 --- 권장 X
    5) @next: 가장 최신 배포판 사용 가능(불안정) --- 권장 X
    6) 알파/베타/RC(Release Candidate) 버전 --- 권장 X

  - "https://semver.npmjs.com" 에서 기호에 대한 호환 버전을 명시적으로 볼 수 있다.

  - package-lock.json
    : 의존성 트리에 대한 정보를 가지고 있다.
    : 저장소에 꼭 같이 커밋해야한다(for. 협업자와 같은 환경을 설정)
    : node_modules가 없을 경우 package-lock.json 파일로 환경을 동일하게 설치 가능하다.

=======================================================================================
#9 Express 웹 서버

* Express 프레임워크
  - http 모듈로 웹 서버를 만들 때, 코드가 복잡하고 확장성도 떨어질 수 있다.
  - Express 프레임워크를 사용하면 코드 관리 용이와 편의성이 높아진다.
  - 다른 프레임워크로 Koa, Hapi 등이 있다.

  - Express 웹 서버 만들기
    1) package.json 작성: [npm init]
    2) Express 설치: [npm install express]
    3) "app.js" 작성: 서버 구동의 핵심 파일
      - app.set("port", 포트): 서버가 실행될 포트 지정
      - app.get(주소, 동작): GET 요청이 올 때, 동작 지정
      - app.listen(포트, 콜백 함수): 몇 번 포트에서 서버 실행 및 콜백 함수 실행
      - snedFile()로 특정 경로의 HTML을 서빙 가능
      ex) "app.js" 파일
        const express = require("express");
        const path = require("path");

        const app = express();
        app.set("port", process.env.PORT || 3000);    // 환경 변수의 PORT or 고정 포트 3000번

        app.get("/", (req, res) => {    // root에 들어왔으면
          // res.send("Hello, Express");    // 문자열 전달
          res.sendFile(path.join(__dirname, "/index.html"));    // '/' + __dirname을 합친 경로에 있는 HTML 서빙
        });

        app.listen(app.get("port"), () => {
          console.log(app.get("port"), "번 포트에서 대기 중");
        });

    4) npm start 시작(package.json이 test command 확인)

  - express-generator로 각종 모듈을 사용할 수 있다.
    1) app.js: 핵심 서버 스크립트
    2) bin/www: 서버를 실행하는 스크립트
    3) public: 외부에서 접근 가능한 파일들 모아둠
    4) views: 템플릿 파일을 모아둠
    5) routes: 서버의 라우터와 로직을 모아둠
      - 데이터베이스 연결(models 사용)


* Express 미들웨어
  - 미들웨어: 요청과 응답의 중간에 위치 / req, res, next가 매개변수인 함수
    1) req: 요청
    2) res: 응답 조작
    3) next(): 다음 미들웨어로 넘김

  - app.use(미들웨어)로 장착
    1) app.use(미들웨어): 모든 경로에서 실행 가능
    2) app.use("/abc", 미들웨어): abc로 시작되는 요청에서 미들웨어 실행
    3) app.post("/abc", 미들웨어): abc로 시작되는 "POST" 요청에서 미들웨어 실행

  ex) 미들웨어 사용, "app.js"
    ...

    app.set("port", process.env.PORT || 3000);

    app.use((req, res, next) => {       // 모든 경로에 대해서 미들웨어 실행
      console.log("모든 요청에 다 실행됩니다.");
      next();     // 다음번 미들웨어로 넘김, 명시적으로 처리할 필요 X
    });

    app.get("/", (req, res, next) => {    // "GET" 요청에 의해서 "/" 경로만 실행
      console.log("GET / 요청에서만 실행됩니다.");
      next();   // 다음번 미들웨어로 넘김
    }, (req, res) => {
      throw new Error("에러는 에러 처리 미들웨어로 갑니다.");
    });

    app.use((err, req, res, next) => {    // err를 포함한 매개변수 4개
      console.error(err);
      res.status(500).send(err.message);      // HTTP 상태 코드와 함께 에러 메시지 전달
    });

    app.listen(app.get("port"), () => {
      ...
    });

  - 에러 처리 미들웨어
    : err, req, res, next 매개변수가 4개
    : err에는 에러 정보가 담김
    : 만약 연결이 안했을 경우, Express가 에러를 알아서 처리
    : 코드는 가장 아래쪽에 위치하도록 한다.

  - 자주 쓰이는 미들웨어 종류
    1) morgan: 로깅(기록)을 도와주는 모듈, 서버로 들어온 요청과 응답을 기록하는 미들웨어
      ex) app.use(morgan("dev"));
      - 자세한 로그 정도에 따라 설정 키워드(= Mode)
        1) "dev": 개발 환경에서 사용
        2) "tiny"
        3) "short"
        4) "common"
        5) "combined": 배포 환경에서 사용
      - 더 자세한 로깅은 'winston' 패키지 이용

    2) cookie-parser: Cookie 파싱하는데 유용한 미들웨어, req.cookies에 쿠키 포함
      - clearCookie(): "expires", "maxAge"를 제외한 옵션이 일치할 때 지우기 가능
      - 쿠키 옵션 지정 가능
        1) expires
        2) domain
        3) httpOnly
        4) maxAge
        5) path
        6) secure
        7) sameSite
      ex) app.use(cookieParser(process.env.COOKIE_SECRET));

    3) express-session: Session을 효율적으로 관리하는 미들웨어
      - 옵션 종류
        1) secret: 쿠키 암호화
        2) cookie: 세션 쿠키 옵션, "s%3A"가 붙은 후 암호화 되어 front 전송
        3) resave: 요청이 왔을 때 세션에 수정사항이 생기지 않아도 다시 저장할지 여부
        4) saveUninitialized: 세션에 저장할 내역이 없어도 세션 저장할지
        5) req.session.save: 수동 저장 가능, 별로 안쓰임

      ex) session 사용
      app.use(session({
        resave: false,
        saveUninitialized: false,
        secret: process.env.COOKIE_SECRET,
        cookie: {
          httpOnly: true,
          secure: false,
        },
        name: "session-cookie",
      }));

      req.session.name = "Choi";    // 세션 등록
      req.sessionID;    // 세션 아이디 확인
      req.session.destory();    // 세션 모두 제거

    4) static: 정적인 파일들을 제공하는 미들웨어
      - 정적 파일 경로 제공
      - 파일이 있을 때, fs.readFile로 직접 읽을 필요 X
      - 요청하는 파일이 없으면, 알아서 next()를 호출하여 다음 미들웨어로 넘어간다.

      ex) "/"와 __dirname 경로를 합친 경로에 public 디렉토리 제공
        app.use("/", express.static(path.join(__dirname, "public")));

      - "컨텐츠 요청 주소"를 "실제 컨텐츠 경로"를 다르게 구성할 수 있어 보안에 약간 도움이 된다.

    5) 요청의 본문을 해석해주는 미들웨어
      - 폼 데이터나 AJAX 요청의 데이터 처리
      - put, patch, post 요청은 req.body에 front에서 온 데이터를 넣어준다.
      - 종류
        1) "json" 미들웨어: 요청 본문이 json인 경우 해석, <express 내장>
          ex) app.use(express.json());

        2) "urlencoded" 미들웨어: 폼 요청에 대해 해석
          ex) app.use(express.urlencoded({extended: false}));
          - extended: false일 경우, "querystring" 모듈을 사용해서 해석, <express 내장>
          - extended: true일 경우, "qs" 모듈을 사용해서 해석, <npm으로 따로 설치>
  
        3) "body-parser" 미들웨어: 버퍼 데이터와 text 데이터일 때 사용, <npm으로 따로 설치>
          ex)
            app.use(bodyParser.raw());
            app.use(bodyParser.text);

        4) "multer" 미들웨어: 이미지, 동영상 데이터를 처리, <npm으로 따로 설치>
  
  - 미들웨어 연결해서 한꺼번에 초기화 가능, 순서 중요!
    ex)
      app.use(
        morgan("dev"),
        express.static("/", path.join(__dirname, "public")),    // 미들웨어에서 파일 찾으면 next 호출 X
        express.json(),
        express.urlencoded({extended: false}),
        cookieParser(process.env.COOKIE_SECRET),
      );

  - next를 호출해야 다음 코드로 넘어간다.
    ex) next();
  - next에 인수를 넣으면 Error 핸들러로 넘어감.
    ex) next(error);
  - next 인수에 "route"를 넣으면 다음 라우터로 넘어감.
    ex) next("route");

  - 데이터 전달(미들웨어간)
    : req, res 객체 안에 값을 넣어 데이터 전달 가능(요청 처리하는 동안만)
    : app.set과의 차이점은 app.set은 서버 내내 유지한다.
    ex) 데이터 전달 예시
      app.use((req, res, next) => {
        req.data = "데이터 넣기";
        next();
      }, (req, res, next) => {
        ...
      });

  - 미들웨어 확장
    ex) 미들웨어 안에 미들웨어
      app.use((req, res, next) => {
        if(process.env.NODE_ENV === "production"){    // production 모드일 때,
          morgan("combined")(req, res, next);     // "combined" 모드 사용
        } else{
          morga("dev")(req, res, next);     // 아니면 "dev" 모드 사용
        }
      });

* 멀티파트 데이터 형식
  - form 태그의 enctype이 multipart/form-data인 경우, body-parser로는 요청 본문 해석 불가
  - "multer" 모듈 이용
  - 옵션 종류
    1) storage: 저장할 공간 정보
    2) diskStorage: 하드디스크에 업로드 파일 저장
    3) destination: 저장할 경로
    4) filename: 저장할 파일명(파일명 + 날짜 + 확장자)
    5) Limits: 파일 개수나 파일 사이즈 제한
  ex) "multer" Setting
    const multer = require("multer");

    const upload = multer({
      storage: multer.diskStorage({
        destination(req, file, done){
          done(null, "upload/");
        },
        filename(req, file, done){
          const ext = path.extname(file.originalname);
          done(null, path.basename(file.originalname, ext) + Date.now() + ext);
        },
      }),
      limits: {fileSize: 5 * 1024 * 1024},
    });

  - 하위 미들웨어 종류
    1) single: 하나의 파일 업로드
      ex)
        app.post("/upload", upload.single("image"), (req, res) => {
          console.log(req.file, req.body);    // req.file안에 업로드 정보 저장
          req.send("ok");
        });

    2) none: 파일 업로드하지 않을 때
      ex)
        app.post("/upload", upload.none(), (req, res) => {
          console.log(req.body);
          res.send("ok");
        });

    3) array: 하나의 요청 body에 여러 파일 있는 경우
      ex)
        app.post("/upload", upload.array("many"), (req, res) => {
          console.log(req.files, res.body);   // req.files안에 업로드 정보 저장
          res.send("ok");
        });

    4) fields: 여러 개의 요청 body에 파일이 하나씩 있는 경우, key가 별도(body 마다)
      ex)
        app.post(
          "/upload",
          upload.fields([
          {name: "image1"},
          {name: "image2"},
          ]),
          (req, res) => {
            console.log(req.files, req.body);   // req.files안에 업로드 정보 저장
            res.send("ok");
          },
        );

* dotenv
  - dot('.') + env('environment')
  - 환경 변수 관리는 Git/SVN과 같은 버전컨트롤에 올려서 코드로 관리하면 보안 위험이 있다. 
  - 비밀 키들을 소스 코드에 그대로 적어두면 소스 코드가 유출됨
  - (.env) 파일을 읽어서 process.env로 만듦
  - (.env) 파일에 환경 변수, 비밀 키 등을 모아두고 관리한다.

* express.Router
  - "app.js" 코드가 길어지는 것을 막음
  ex 1) "app.js" 코드
    ...
    const path = require("path");
    dotenv.config();
    const indextRouter = require("./routes");     // routes 폴더 안에 index.js 들고옴
    const userRouter = require("./routes/user");  // routes/user 폴더 안에 user.js 들고옴
    ...
      name: "session-cookie",
    }));

    app.use("/", indexRouter);
    app.use("/user", userRouter);

    app.use((req, res, next) => {     // 앞에서 send()가 되지 않아 지정하지 않은 경로에 대해
      res.status(404).send("Not Found");
    });

    app.use((err, req, res, next) => {  // 에러가 날 경우
      ...
    });
  
  ex 2) "routes/index.js" 코드
    const express = require("express");
    
    const router = express.Router();

    router.get("/", (req, res) => {   // GET '/' 라우터
      res.send("Hello, Express");
    });

    moule.exports = router;

  ex 3) "routes/user.js" 코드
    const express = require("express");

    const router = express.Router();

    router.get("/", (req, res) => {     // GET '/user' 라우터: '/user/가 됨
      res.send("Hello, User");
    });
    
    module.exports = router;

  - 라우트 매개변수(:id)
    : req.params.id로 받기 가능
    : 동적으로 변하는 부분에 사용한다.
    : 일반 라우터 코드보다 뒤에 위치한 코드 작성해야 한다.
    ex)
      router.get("/user/:id", function(req, res){
        console.log(req.params, req.query);
      });
  
  - 404 라우터로 요청과 일치하는 라우터가 없는 경우 대비
    ex) 404 라우터
    app.use((req, res, next) => {
      res.status(404).send("Not Found");    // 해당 부분이 없으면 "Cannot GET 주소" 문자열 표시됨
    });

  - router.route로 묶어 주소는 같지만 요청 메소드가 다른 코드가 있을 경우 대비
    ex) 
      router.route("/abc")
        .get((req, res) => {
          res.send("GET /abc");
        })
        .post((req, res) => {
          res.send("POST /abc");
        });

* Express의 "req", "res" 객체
  - 원래의 req, res 객체를 확장
  - "req" 속성
    1) req.app: 사용하는 app 객체 접근 가능
      ex) req.app.get("port")

    2) req.body: body-parser 미들웨어가 만드는 요청의 본문을 해석한 객체
    3) req.cookies: cookie-parser 미들웨어가 만드는 요청의 쿠키를 해석한 객체
    4) req.ip: 요청의 ip 주소
    5) req.params: 라우트 매개변수 정보
    6) req.query: 쿼리스트링 정보
    7) req.signedCookies: 서명된 쿠키 / 일반 쿠키들은 req.cookies
    8) req.get: 헤더의 값을 가져올 때 사용
  
  - "res" 메소드
    1) res.app: 사용하는 app 객체 접근
    2) res.cookie(키, 값, 옵션): 전달할 쿠키 설정
    3) res.clearCookie(키, 값, 옵션): 쿠키 제거, (키, 값, 옵션)이 같아야함
    4) res.end(): 데이터 없이 응답(ack)
    5) res.json(json): JSON 형식의 응답을 보냄
    6) res.redirect(주소): 리다이렉트할 주소와 함께 응답
    7) res.render(뷰, 데이터): 템플릿 엔진을 렌더링해서 응답
    8) res.send(데이터): 데이터(문자열, HTML, 버퍼, 객체, 배열)와 함께 응답을 보냄
    9) res.sendFile(경로): 경로에 위치한 파일로 응답
    10) res.set(헤더, 값): 응답의 헤더를 설정
    11) res.status(코드): HTTP 상태 코드 지정

  - res 메소드 체이닝 지원
    ex)
      res
        .status(201)
        .cookie("test", "test")
        .redirect("/admin");
  - 하나의 요청에 대한 응답은 한 번만 보내야한다(두 번  이상 보낼 경우 Error)
    : Error 메시지: "Can't set headers after they are sent

* 템플릿 엔진 사용
  - HTML의 정적인 단점을 개선
    -> 템플릿 엔진 사용 시, 동적 페이지 작성 가능

  - 종류
    1) Pug(= 구 Jade)
      - "Ruby" 언어와 문법이 비슷하다.
      - express에 app.set으로 Pug 연결
      ex) Pug 기본 실행
        npm install express-generator -g    // 앱 생성기 express 설치(전역)
        express --view=pug <이름>   // pug 템플릿 엔진 사용 앱 만들기
        npm install   // 종속 항목들 설치
        npm start     // 실행

      - Indentation으로 문장의 끝을 알 수 있다.("Python" 언어와 비슷)
      - id는 '#'으로 class는 '.'으로 표현
      - 변수 사용
        1) res.render()에 두 번째 인자에 Pug 변수 추가: 미들웨어간 공유 X
          ex) res.render("index", {title: "Express"});

        2) res.locals 객체에 넣기: 미들웨어간 공유 O
          ex)
            res.locals.title = "Express";
            res.render("index");

        3) 퍼그 파일 내에서 '-' 뒤에 자바스크립트 사용으로 변수 선언 가능
          ex) in (.pug)
            - const node = "Node.js"

        ex 1) in (.js)파일
          router.get("/", function(req, res, next) {
            1) or 2) 사용
          });

        ex 2) in (.pug)파일
          - const node = "Node.js"      // 3) 사용
          - const js = "Javascript"     // 3) 사용
          h1= title     // '= 변수' 이용
          p Welcome to #{title}   // '#{변수}'이용
          button{class=title, type="submit" } 전송
          input(placeholder=title + " 연습")
          p #{node}와 #{js}     //'#{변수}' 이용
        
      - <> html 코드들은 Default로 자동 이스케이프 해준다.
        ex)
          p = "<strong> 이스케이프</strong>"    // 자동 이스케이프
          // <p>&lt;strong&gt;이스케이프&lt;/strong&gt;</p> 로 출력

          p != "<strong> 이스케이프</strong>"   // 이스케이프 안함
          // <p><strong>이스케이프</strong></p> 로 출력

      - 퍼그 반복문 사용
        ex)
          ul
            each fruit, index in ["사과", "오렌지", "복숭아", "바나나"]
              li= `${index + 1}번째 ${fruit}`     // 템플릿 문자열 '`' 사용 가능

      - 퍼그 조건문 사용
        ex 1) if-else 사용
          if isLoggedIn
            div 로그인 되었습니다.
          else
            div 로그인이 필요합니다.
        
        ex 2) case-when 사용
          case fruit
            when "apple"
              p 사과입니다
            when "banana"
              p 바나나입니다.
            when "orange"
              p 오렌지입니다.
            default
              p 사과도 바나나도 오렌지도 아닙니다.

      - 퍼그 include 사용
        : (.pug) 파일에 다른 (.pug) 파일을 넣어서 사용
        : include로 파일 경로 지정
        ex 1) in (main.pug) 파일
          include header      // (header.pug) 파일 포함
          main
            h1 메인 파일
            p 다른 파일을 include할 수 있습니다.
          include footer      // (footer.pug) 파일 포함

        ex 2) in (header.pug) 파일
          header
            a(href="/") Home
            a(href="/about") About

        ex 3) in (footer.pug) 파일
          footer
            div 푸터입니다

      - *퍼그의 extends와 block 사용
        : 공통되는 레이아웃을 block으로 하여 extends하여 사용
        ex) (layout.pug) 파일
          doctype html
          html
            head
              title= title
              link(rel="stylesheet", href="/style.css")
              block style   // style 블락으로 자리를 잡아놓음
            body
              header 헤더입니다.
              block content       // content로 자리를 잡아놓음
              footer 푸터입니다.
              block script      // script로 자리를 잡아놓음

        ex 2) (body.pug) 파일
          extends layout        // (layout.pug) 파일을 확장하여 사용
          
          ...               // 이 부분은 layout 내용이 들어감

          block content     // content 블락 부분 정의
            main
              p 내용입니다.
          
          block script      // script 블락 부분 정의
            script(src="/main.js")

    2) Nunjucks
      - 코드 길이가 "Pug" 보다 길다.
      - Nunjucks 사용
        1) Pug를 지우고 Nunjucks 설치
          - [npm uninstall pug]
          - [npm install nunjucks]

        2) (app.js) 파일 안에 view engine을 njk, 확장자는 "html"로 설정
          ex) (app.js) 파일
          app.set("view engine", "html");
          nunjucks.configure("views", {
            express: app,
            watch: true,
          });
      
      - 넌적스 변수 사용
        : {{변수}}
      
      - 넌적스 내부 변수 선언
        : {% set 자바스크립트 구문}

      - 넌적스 반복문 사용
        : {% %} 안에 for in 사용
        : 인덱스는 loop.index로 접근
        ex)
          <ul>
            {% set fruits = ["사과", "배", "오렌지", "바나나", 복숭아"] %}
            {% for item in fruits %}
            <li>{{loop.index}}번째 {{item}}</li>
            {% endfor %}    // endfor로 for in문 명시적으로 알려준다.
          </ul>

      - 넌적스 조건문 사용
        : {% if %} 안에 조건문 사용
        : {% if %}, {% elif %}, {% else %}, {% endif %}로 사용
      
      - 넌적스 include 사용
        : {% include "<이름>.html" %}로 사용
      
      - 넌적스 layout 사용
        : {% extends "<이름>.html" %}로 사용
        : {% block <블락이름> %}로 사용

    3) EJS
    4) Handlebars

  - 에러 처리 미들웨어 사용
    : 템플릿 엔진 종류와 상관없이 템플릿 엔진 변수를 설정하고 error 템플릿을 렌더링함
    ex) in (app.js) 파일
      app.use((err, req, res, next) = >{
        res.locals.message = err.message;
        res.locals.error = process.env.NODE_ENV !== "production" ? err : {};
        res.status(err.status || 500);
        res.render("error");
      });


=======================================================================================
#10 웹 어플리케이션과 DB(MySQL)

* 데이터베이스(DB)
  - 관련성을 가지며 중복이 없는 데이터들의 집합
  - 영구적으로 저장할 공간: 서버를 재시작하면 데이터는 사라지는 문제 해결
  - DBMS: 데이터베이스를 관리하는 시스템, 하위 레벨 생각 X, SQL Query 사용
  - RDBMS: 관계형 데이터베이스를 관리하는 시스템
  - MySQL은 RDBMS, 개인용(비영리)은 무료 / 기업용(영리)은 유료 -> MariaDB, 모두 무료
  - 여러 사람 동시 접근 가능
  - 권한 차등 부여 가능

* MySQL 설치
  - Workbench: GUI 환경으로 MySQL DBMS 사용하는 툴(원래는 CLI 환경)
  - MySQL 공식 사이트에서 설치(to Windows)
    1) Community 버전: 개인용(비영리)
    2) MySQL Server, Workbench 설치
    3) root password 설정: 보안 중요!!
  
  - MySQL 설치(to Linux, Ubuntu)
    1) sudo apt-get update
    2) sudo apt-get install -y mysql-server
    3) mysql_secure_installation: 권장
      - root 계정 비밀번호 복잡하게 해줌
      - Sample DB 삭제
      - 익명 접속 비활성화

    - Ubuntu는 workbench가 없다, 콘솔로 작업

* MySQL 실행
  - cmd 에서 MySQL 설치 경로로 이동(bin 폴더)
  - mysql -h <호스트> -u <사용자> -p <비밀번호>
    : <비밀번호> 전에 Enter 입력 후 <비밀번호> 입력

  - 프롬프트가 "mysql>"로 바뀌면 접속 성공!

* DB 생성
  1) 콘솔에서 MySQL 프롬프트에 접속
  2) CREATE SCHEMA nodejs;      vs DROP SCHEMA `nodejs`;  --- nodejs DB 삭제
    - nodejs DB 생성
  3) use nodejs;
    - 생성한 nodejs DB 접속

* Table 생성
  1) CREATE TABLE 데이터베이스명.테이블명( ... );

* Column(정보) 옵션, 데이터는 Row로 들어간다.
  - INT: 정수 자료형 vs FLOAT, DOUBLE은 실수
  - VARCHAR: 문자열 자료형, 가변 길이 vs CHAR은 고정 길이
  - TEXT: 긴 문자열은 TEXT로 별도 저장
  - DATETIME: 날짜 자료형 저장
  - TINYINT: -128 ~ 127까지 저장, boolean 값 표현으로 사용되기도 함.
  
  - NOT NULL: 빈 값은 받지 않음 vs NULL은 빈 값 허용
  - AUTO_INCREMENT: 숫자 자료형인 경우 다음 Row가 저장될 경우 자동으로 1 증가

  - UNSIGNED: 0과 양수만 허용
  - ZEROFILL: 숫자의 자리 수가 고정된 경우 빈 자리에 0을 넣음
  - DEFAULT now(): 날짜 Column의 기본값을 현재 시간으로 지정

* Primary Key
  ex) PRIMARY KEY(id)
  - id가 테이블에서 Row를 특정할 수 있게 해주는 고유한 값
  - 학번, 주민등록번호 같은 개념

* Foreign Key
  - 다른 테이블의 Primary Key 참조
  - 다른 테이블과의 관계가 있다는 것을 명시적으로 보여줌
  - ON DELETE CASCADE, ON UPDATE CASCADE는 관련된 테이블 각각 delete, updqte 옵션 vs SET NULL or NO ACTION 등 있다.

* Unique Index
  ex) UNIQUE INDEX name_UNIQUE (name ASC)
  - 해당 Column이 고유해야 함을 나타내는 옵션, Primary Key는 아니다.
  - name_UNIQUE는 옵션 이름
  - ASC는 인덱스를 오름차순으로 저장함을 의미 vs DESC: 내림차순

* Table 옵션
  - COMMENT: 테이블에 대한 보충 설명(필수 X)
  - DEFAULT CHARSET: utf8 사용해야 한글 사용 가능
  - ENGINE: InnoDB 사용 vs MyISAM

* Table 명령어
  - SHOW DATABASES;
    : 스키마(데이터베이스) 조회

  - SHOW TABLES;
    : 테이블 목록 조회

  - DESC 테이블명;
    : Column, row 조회

  - DROP TABLE 테이블명;
    : 테이블 삭제

* CRUD 작업: 데이터를 제어하는 방법 4가지
  - Create, Read, Update, Delete 두문자어
  - DB에서 가장 많이 하는 작업 4가지.

  1) Create
    - 데이터 생성(추가)
    - INSERT INTO 테이블(컬럼명들) VALUES (값들)
  
  2) Read
    - 데이터 조회
    - SELECT 컬럼 FROM 테이블명
    - SELECT 컬럼 FROM 테이블명 WHERE 조건(AND / OR 사용)
    - ORDER BY ASC / ORDER BY DESC: 오름차순 / 내림차순 정렬
    - LIMIT / OFFSET: 조회할 개수 제한 / 앞의 데이터(Row) Skip 후 조회
      ex) OFFSET이 2면 세 번째 Row(Data)부터 찾는다.

  3) Update
    - 데이터 수정
    - UPDATE 테이블명 SET 컬럼=새로운 값 WHERE 조건

  4) Delete
    - 데이터 삭제
    - DELETE FROM 테이블명 WHERE 조건


* 시퀄(SQL)라이즈 사용
  - SQL 작업을 쉽게 할 수 있도록 도와주는 라이브러리(MySQL, MariaDB, Postgre, SQLite, MSSQL)
  - 시퀄라이즈 ORM(Object Relational Mapping): 객체와 데이터를 1:1 매핑
  - Javascript 문법을 이용하여 데이터베이스를 제어 가능한 패키지

  - npx sequelize init 으로 config와 models 등 만들어준다.(덮어 씌울 경우는 --force 옵션 추가)
  - 'mysql' or 'mysql2' npm 패키지는 Node.js와 MySQL을 이어주는 드라이버(패키지)다.

  - 시퀄라이즈 사용 순서
    1) npm init -y
    2) npm install express
    3) npm install express-generator --global
    4) express --view=pug
    5) npm install nodemon --save-dev
    6) npm install mysql2 sequelize sequelize-cli
    7) npx sequelize init

    8) config.json 파일로 DB 옵션 지정
      ex) config.json
        "development": {          // or test(개발과 서비스 중간), production(서비스용)
          "username": "root",     
          "password": null,
          "database": "database_development",     // 목적 DB 서버 접속
          "host": "127.0.0.1",        // ip주소
          "dialect": "mysql",       // 다른 DB 종류 옵션 지정(Maria, Oracle DB 등)
          "operatorsAliases": false
        },

    9) DBMS에서 미리 생성 or "sequelize-cli"로 모델을 생성하는 것은 권장 X --- 아직 옵션들을 명확하게 지정 불가
      ex) sequelize-cli로 모델 생성
        npx sequelize model:generator --name Comments --attributes comment:string,create_at:date
        // Comments 테이블 생성
        // Comment로 만들어도 Comments로 연결
        // Model 폴더에 (.js)파일 생성
        // migrations 폴더 안에 생성, 삭제의 옵션을 지정할 수 있는 목록이 들어감
    
    10) 모델 활성화
      ex) index.js에 모델 연결
        const Sequelize = require("sequelize");
        const User = require("./user");
        const Comment = require("./comment");

        ...
        db.sequelize = sequelize;

        db.User = User;
        db.Comment = Comment;

        User.init(sequelize);
        Comment.init(sequelize);

        User.associate(db);       // 관계 설정
        Comment.associate(db);

        module.export = db;
    
    11) models/indes.js 를 수정하여 DB 모델과 연결한다.
      ex) models/indes.js
        const Sequelize = require("sequelize");

        const env = process.env.NODE_ENV || "developent";
        const config = require("../config/config.json");    // 설정 로딩
        const db = {};

        const sequelize = new Sequelize(        // DB와 연결 가능
          config.database,
          config.username,
          config.password,
          config
          );
        db.sequelize = sequelize;     // db 객체 안에 넣어줌

        module.exports = db;      // db 내보내기
  
    12) app.js에서 sequelize.sync로 DB와 연결한다.

  - 시퀄라이즈 모델의 자료형 vs MySQL의 자료형
    1) STRING(100) vs VARCHAR(100)
    2) INTEGER vs INT
    3) BOOLEAN vs TINYINT
    4) DATE vs DATETIME
    5) INTEGER, UNSIGNED vs INT, UNSIGNED
    6) allowNull: false vs NOT NULL
    7) unique: true vs UNIQUE
    8) defaultValue: Sequelize.NOW vs DEFAULT now()
  
  - 시퀄라이즈 모델 옵션: define 메소드의 세 번째 인자로 테이블 옵션 지정
    1) timestamps
      : true면 createAt(생성 시간), updatedAt(수정 시간) Column을 자동 생성
    2) paranoid
      : true면 deleteAt(삭제 시간) Column을 만듦
      : 복구를 위해 완전히 삭제하지 않고 deleteAt에 표시
    3) underscored
      : Camel case로 생성되는 Column을 Snake case(_로 연결됨)
    4) modelName
      : 모델 이름 설정
    5) tableName
      : 테이블 이름 설정
    6) charset, collate
      : 한글 설정을 위해 필요
      : 이모티콘(emoji) 포함하려면 "utf8mb4"


  - 관계 정의(associate)
    1) 1:N, N:1
      - hasMany(), belongsTo()로 사용
      ex) 사용자.hasMany(댓글)  // 한 명의 사용자가 여러 댓글
      ex) 댓글.belongsTo(사용자)  // 여러 개의 댓글은 한 명의 사용자가
    3) 1:1
      - hasOne()과 belongsTo()를 사용
      ex) 사용자.hasOne(사용자 정보)

    - belongsTo()쪽에 Column이 생긴다. ex) 댓글 테이블에 컬럼이 생김.

    4) N:M(다대다)
      - belongsToMany()로 표현
      ex) 게시글.belongsToMany(해시태그), 해시태그.belongsToMany(게시글)
      - 다대다 관계는 DB 특성상 중간 테이블(연결 관계)이 생긴다. ex) 테이블 이름은 "게시글해시태그"
  
  - 시퀄라이즈 쿼리
    1) 생성(INSERT - INTO)
    // INSERT INTO nodejs.users (name, age, married, comment) VALUES ("Louis", 24, 0, "자기소개1");
    const {User} = require("../models");
    User.create({
      name: "Louis",
      age: 24,
      married: false,
      comment: "자기소개1",
    });

    2) 조회
    // SELECT * FROM nodejs.users;
    User.findAll({});
    
    // SELECT name, married FROM nodejs.users;
    User.findAll({
      attributes: ["name", "married"],
    });

    // SELECT name, age FROM nodejs.users WHERE married = 1 AND age > 30;
    const { Op } = require("sequelize");
    const { User } = require("../models");
    User.findAll({
      attributes: ["name", "age"],
      where: {
        married: 1,
        age: { [Op.gt]: 30 },
      },
    });

    // SELECT id, name FROM users WHERE married = 0 OR age > 30;
    const { Op } = require("sequelize");
    const { User } = require("../models");
    User.findAll({
      attributes: ["id", "name"],
      where: {
        [Op.or]: [{married: 0}, {age: { [Op.gt]: 30} }],    // gt: greater than
      },
    });

    // SELECT id, name FROM users ORDER BY age DESC;
    User.findAll({
      attributes: ["id", "name"],
      order: ["age", "DESC"],
    });

    // SELECT id, name FROM users ORDER BY age DESC LIMIT 1;
    User.findAll({
      attributes: ["id", "name"],
      order: ["age", "DESC"],
      limit: 1,
    });

    // SELECT id, name FROM users ORDER BY age DESC LIMIT 1 OFFSET 1;
    User.findAll({
      attributes: ["id", "name"],
      order: ["age", "DESC"],
      limit: 1,
      offset: 1,
    });

    3) 수정(UPDATE - SET)
    // UPDATE nodejs.users SET comment = "바꿀 내용" WHERE id = 2;
    User.update({
      comment: "바꿀 내용",           // SET
    },
    {
      where: {id: 2},
    });

    4) 삭제
    // DELETE FROM nodejs.users WHERE id = 2;
    User.destroy({
      where: { id: 2 },
    });


  - 관계 쿼리
    : 결과값이 Javascript 객체.
      ex) const user = await User.findOne({});

    : include로 JOIN과 비슷한 기능 수행 가능 --- 복수개로 들고온다는 뜻으로 's'가 붙음
    : include에 where와 attributes 사용 가능  
      ex)
      const user = await User.findOne({
        include: [{
          model: Comment,
        }]
      });

    : 다대다 모델 접근 가능
      ex) db.sequelize.models.PostHashtag

    : get + 모델명으로 관계 있는 데이터 로딩 가능
      ex)
      const user = await User.findOne({});
      const comments = await user.getComments();

    : as로 모델명 변경 가능
      ex)
      db.User.hasMany(db.Comment, {foreignKey: "commenter", sourceKey: "id", as: "Answers"});
      
      // Query
      const user = await User.findOne({});
      const comments = await user.getAnswers();

  - 생성 쿼리
    : add + 모델명으로 추가
    ex)
      const user = await User.findOne({});
      const comment = await Comment.create();
      await user.addComment(comment);
      // await user.addComment(comment.id);
      // await user.addComment([comment1, comment2]);    // 여러 개

  - 수정 쿼리
    : set + 모델명
  
  - 삭제 쿼리
    : remove + 모델명

  - Raw 쿼리
    : sequelize.query("...");
    ex) const [result, metadata] = await sequelize.query("SELECT * FROM comments);


=======================================================================================
#11 NoSQL(MongoDB)

* NoSQL
  - 관계형 DB(SQL) vs 관계형 DB X(NoSQL)
  - 대표적 NoSQL DB는 MongoDB
  - MEAN(MongoDB, Express, Angular, Node.js) 풀 스택

* SQL vs NoSQL
  - SQL
    : 규칙에 맞는 데이터 입력
    : 테이블 간 JOIN 지원
    : 안정성, 일관성 --- 규칙에 맞게 저장하므로
    : table, row, column
  
  - NoSQL
    : 자유로운 데이터 입력
    : 컬렉션 간 JOIN 미지원
    : 확장성, 가용성 --- 규칙 없이 저장하므로
    : collection, document, field

* MongoDB
  - "JOIN"을 "aggregate"로 흉내 가능
  - 빅데이터, 메시징, 세션 관리 등(비정형 데이터) 경우에 사용

  - 윈도우 설치: MongoDB, Compass(MySQL의 Workbench)
    1) MongoDB 설치(community)
    2) Install MongoD as a Service: 클라우드 기능(연습 목적이면 체크 해제)
    3) Compass 설치 체크
  
  - 윈도우 실행
    1) 설치된 경로에서 bin 폴더에 몽고디비를 실행(or 사용자 환경 변수 설정)
      : 콘솔에서 "mongod" 입력하여 서버 실행
      : "mongod"의 'd'는 daemon을 뜻함(백그라운드 실행)

    --- 처음 실행 ---
    2) 콘솔에서 "mongo"로 접속
    3) Admin 설정
      : use admin
      : db.createUser({user: "이름", pwd: "비밀번호", roles: ["root"]}) --- 관리자 계정(root)
    4) mongod를 입력했던 콘솔 종료
    5) mongod --auth로 서버 실행(지정한 User에 대해서만 "show dbs;" 조회 가능)
    --- 처음 실행 ---

    6) mongo admin -u 이름 -p 비밀번호로 접속


  - 리눅스 설치
    1) sudo apt-get update
    2) sudo apt-get install -y mongodb-org

  - 리눅스 실행
    1) sudo systemctl start mongod: 서버 시작
    
    --- 서버 명령어 ---
    1.1) sudo systemctl stop mongod: 서버 중지
    1.2) sudo systemctl restart mongod: 재시작
    --- 서버 명령어 ---

    --- 처음 실행 ---
    2) mongo: 서버 접속
    3) use admin: admin 접속
    4) db.createUser({user: "이름", pwd: "비밀번호", roles: ["root"]})
    5) sudo systemctl stop mongod
    6) vim /etc/mongod.conf: 설정 파일 수정
      ex) conf 파일 맨 끝 두줄 추가
      ...
      security:
        authorization: enabled
    7) sudo systemctl start mongod
    --- 처음 실행 ---

    8) mongo admin -u [이름] -p [비밀번호]로 접속

  - connection 생성(after 설치, 실행)
    1) Fill in connection Fields individually
    2) Authentication Username / Password로 변경


  - DB, Collection 생성
    1) use DB이름;
      ex) use nodejs;
      - 해당 DB가 없으면 생성, 있으면 사용
      - 새로 생성했을 경우, show dbs; 해도 안보인다.(collection을 생성해야 보임)

    2) db.createCollection("이름");
      ex) db.createCollection("users");
      - Collection을 생성하는 명령어
      - 실제로는 document를 넣는 순간 collection이 자동 생성됨.
      - "show collections"로 조회
      - 관용적으로 Collection은 복수 명사로 만든다.

  - CRUD
    1) Create
      - MongoDB는 Column을 정의 안해도 됨
      - Javascript의 자료형을 따름(차이점도 있다)
      - ObjectId: 몽고디비의 자료형, 고유 아이디, 자동으로 저장
      - sava method로 저장
        ex) user Collection에 저장
          db.users.save({name: "Louis", age: 26, married: false, comment: "하이", createdAt: new Date() });

      - 관계 설정: Objectid를 찾은 뒤 Collection에 넣는다.(find 메소드 이용)
        ex) users와 comments의 관계 설정
          db.users.find({name: "Louis"}, {_id: 1});       // 1은 보겠다, 0은 보지 않겠다
          db.comments.save({commenter: objectId("해당 user의 ObjectId"), comment: "하이요", createdAt: new Date()});

    2) Read
      - db.컬렉션 이름.find({조건}, {조회 목록});
      - db.컬렉션 이름.findOne(); 으로 가장 먼저 넣은 하나만 조회 가능
      - 두 번째 인수로 조회할 필드 선택 가능(1은 추가, 0은 제외)

      - $gt, $or로 조건 연산자 이용
        ex 1) 나이는 30 이상이고, 결혼한 user의 _id를 제외한 name과 age만 조회
          db.users.find({age: {$gt: 30}, married: true}, {_id:0, name: 1, age:1 });

        ex 2) 나이는 30 이상이거나 결혼하지 않은 user의 _id를 제외한 name과 age만 조회
          db.users.find({$or: [{age: {$gt: 30}}, {married: false}]}, {_id: 0, name: 1, age: 1});

      - sort 메소드로 정렬(오름차순: 1, 내림차순: -1)
        ex) id는 제외하고 name과 age를 age 결과에 대해 내림차순(-1) 정렬하여 조회
          db.users.find({}, {_id: 0, name: 1, age: 1}).sort({age: -1});

      - limit 메소드로 조회할 document 개수 제한
        ex 1) limit(1)로 1개만 조회
          db.users.find({}, {_id: 0, name: 1, age: 1}).sort({age: -1}).limit(1);

        ex 2) skip(1)로 1개 skip하고 그 다음 1개 조회
          db.users.find({}, {_id: 0, name: 1, age: 1}).sort({age: -1}).limit(1).skip(1);

    3) Update
      - update 메소드로 쿼리
      - 첫 번째 인수로 수정 대상, 두 번째 인수로 수정 내용
      - "&set"을 붙이지 않으면 Document 전체가 대체됨.
      ex) Louis 이름에 해당하는 user의 comment를 "바이요"로 수정
        db.users.update({name: "Louis"}, {$set: {comment: "바이요"}});

      - 해당 쿼리 결과로 수정된 개수가 나온다.

    4) Delete
      - remove 메소드로 쿼리
      - 첫 번째 인수로 삭제할 대상
      ex) name이 Louis인 user Document 삭제
        db.users.remove({name: "Louis"});
  
      - 성공 시 삭제된 개수 결과로 나온다.

* Mongoose(몽구스)
  - MongoDB 작업을 도와주는 라이브러리다.(MySQL은 Sequelize)
  - Javascript 'O'bject와 'D'ocument를 'M'apping
  - 몽고디비에 없는 기능들을 몽구스가 보완. ex) JOIN 기능 추가
  - "npm install mongoose" 로 몽구스 설치

  1) MongoDB 연결하기
    ex) schemas/index.js
      const mongoose = require("mongoose");     // 몽구스 패키지 불러오기

      const connect = () => {
        if(process.env.NODE_ENV !== "production"){
          mongoose.set("debug", true);      // 디버깅 모드를 킴(콘솔에 쿼리 출력), production mode에서는 꺼야함.
        }
        mongoose.connect("mongodb://이름:비밀번호@localhost:포트번호/admin", {      // 보안 위험!!!!
          dbName: "nodejs",
          useNewUrlParser: true,
          useCreateIndex: true,
        }, (error) => {
          if(error){
            console.log("몽고디비 연결 에러", error);
          } else{
            console.log("몽고디비 연결 성공");
          }
        });
      };
      
      mongoose.connection.on("error", (error) => {
        console.error("몽고디비 연결 에러", error);     // 에러날 경우
      });
      
      mongoose.connection.on("disconnected", () => {
        console.error("몽고디비 연결이 끊겼습니다. 연결을 재시도합니다.");
        connect();      // 재시도
      });

      module.exports = connect;


  2) app과 연결(Express app)
    ex) app.js
      const express = require("express");       // express 패키지 로딩
      const path = require("path");             // path 패키지 로딩
      const morgan = require("morgan");         // morgan 패키지 로딩
      const nunjucks = require("nunjucks");     // 템플릿 엔진 nunjucks 로딩

      const connet = require("./schemas");      // ./schemas/index.js 로딩(DB 연결 파트)

      const app = express();
      app.set("port", process.env.PORT || 3002);
      app.set("view engine", "html");
      nunjucks.configure("views", {
        express: app,
        watch: true,
      });
      connect();        // Mongoose와 MongoDB 연결 시도

      app.use(morgan("dev"));         // 개발 모드로 로깅
      app.use(express.static(path.join(__dirname, "public")));
      app.use(express.json());
      app.use(express.urlencoded({ extended: false}));

      app.use((req, res, next) => {       // 라우팅 파일이 존재하지 않을 경우
        const error = new Error(`${req.method} $(req.url) 라우터가 없습니다.`);
        error.status = 404;
        next(error);
      });

      app.use((err, req, res, next) => {        // 에러
        res.locals.message = err.message;
        res.locals.error = process.env.NODE_ENV !== "production" ? err : {};
        res.status(err.status || 500);
        res.render("error");
      });

      app.listen(app.get("port"), () => {
        console.log(app.get("port"), "번 포트에서 대기 중");
      });

  3) 스키마(schemas) 정의: MySQL의 테이블과 같이 정해진 데이터만 들어갈 수 있도록 강제한다.
    ex 1) schemas/user.js
      const mongoose = require("mongoose");

      const { Schema } = mongoose;
      cosnt userSchema = new Schema({
        name: {
          type: String,       // 자료형
          require: true,      // 필수 여부
          unique: true,       // 고유 여부
        },
        age: {
          type: Number,
          required: true,
        },
        married: {
          type: Boolean,
          required: true,
        },
        comment: String,
        createdAt: {
          type: Date,
          default: Date.now,    // 기본값
        },
      });

    ex 2) schemas/comment.js
      const mongoose = require("mongoose");
      const { Schema } = mongoose;
      const { Types: { ObjectId } } = Schema;
      const commentSchema = new Schema({
        commenter: {
          type: ObjectId,
          required: true,
          ref: "User",
        },
        comment: {
          type: String,
          require: true,
        },
        createdAt: {
          type: Date,
          default: Date.now,
        },
      });

      module.exports = mongoose.model("Comment", commentSchema);

  4) 라우터(routes) 작성: Front-end 코드는 AJAX 요청 위주로, Back-end 코드는 Router 위주로
    ex 1) routes/index.js
      const express = require("express");
      const User = require("../schemas/user");
      
      const router = express.Router();

      router.get("/", async(req, res, next) => {
        try{
          const users = await User.find( {} );    // 사용자 목록을 다 가져옴
          res.render("mongoose", { users });    // views/mongoose 에서 rendering
        } catch(err){
          console.error(err);
          next(err);
        }
      });

      module.exports = router;

    ex 2) routes/users.js
      const express = require("express");
      const User = require("../schemas/user");
      const comment = require("../schemas/comment");

      const router = express.Router();

      router.route("/")
        .get(async (req, res, next) => {
          try{
            const users = await User.find({});      // get: 사용자 목록을 가져옴
            res.json(users);      // 사용자 목록을 json으로 전달
          } catch(err){
            console.error(err);
            next(err);
          }
        })
        .post(async(req, res, next) => {
          try{
            const user = await User.create({      // post: 사용자 생성
              name: req.body.name,      // 이름
              age: req.body.age,        // 나이
              married: req.body.married,      // 결혼 여부
            });
            console.log(user);
            res.status(201).json(user);
          }catch(err){
            console.error(err);
            next(err);
          }
        });

        router.get("/:id/comments", async(req, res, next) => {
          try{
            // get으로 사용자 comment 목록 들고오기
            const comments = await Comment.find({commenter: req.params.id}).populate("commenter");
            console.log("comments");
            res.json(comments);
          } catch(err){
            console.log(err);
            next(err);
          }
        });

        module.exports = router;

    ex 3) routes/comments.js
      const express = require("express");
      const Comment = require("../schemas/comment");

      const router = express.Router();

      router.post("/", async(req, res, next) => {
        try{
          const comment = await Comment.create({        // comment를 만듬
            commenter: req.body.id,
            comment: req.body.comment,
          });
          console.log(comment);
          const result = await Comment.populate(comment, { path: "commenter"});
          res.status(201).json(result);     // 응답으로 결과를 반환
        } catch(err){
          console.error(err);
          next(err);
        }
      });

      router.route("/:id")        // comment의 id가 들어옴
        .patch(async(req, res, next) => {     // 수정
          try{
            const result = await Comment.update({
              _id: req.params.id,
            }, {
              comment: req.body.comment,
            });
            res.json(result);
          } catch(err){
            console.error(err);
            next(err);
          }
        })
        .delete(async(req, res, next) => {      // 삭제
          try{
            const result = await Comment.remove({
              _id: req.params.id
            });
            res.json(result);
          } catch(err){
            console.error(err);
            next(err);
          }
        });

        module.exports = router;

  5) 라우터 연결

=======================================================================================
#12

* 프로젝트 만들기(nodebird)
  - express-generator로 만들면 약간의 버그 사항이 있어 직접 만듦
  
  1) 폴더 생성과 package.json 파일 생성
  2) npm install mysql2 sequelize seqeulize-cli
    - npx sequelize init
  3) 폴더 구조 만들기
    - passport: 로그인 기능
    - routes: 라우터
    - public: 정적 파일
    - views: 템플릿 엔진
  4) app.js, .env 파일 생성
  5) 패키지 설치
    - express
    - cookie-parser
    - express-session
    - morgan
    - multer
    - dotenv
    - 템플릿 엔진

  6) app.js 작성, .env 같이 추가
  7) 라우터 생성
    - routes/page.js: 템플릿 엔진을 렌더링하는 라우터
    - views/layout.html: 로그인/유저 정보 화면
    - views/main.html: 메인 화면(게시글 조회)
    - views/profile.html: 프로필 화면(팔로잉 관계)
    - views/error.html: 에러 발생 시 에러 표시 화면
    - public/main.css: 화면 CSS
  
  8) DB 설정(mysql)
    - models/user.js: 사용자 테이블과 연결
      1) provider: 카카오 로그인
      2) local: 로컬 로그인
      3) snsId: 카카오 로그인인 경우 주어지는 id
    - models/post.js: 게시글 내용, 이미지 경로 저장(이미지는 file로 저장)
    - models/hashtag.js: 해시태그 이름을 저장(for. 해시태그 검색)
    - models/index.js
      : 모델 로딩(require)
      : 모델 간 관계가 있는 경우 설정
      : User(1) : Post(다) / Post(다) : Hashtag(다) / User(다): User(다)
    - associate 작성(user.js, post.js, hashtag.js)
    - config.json 작성
    - app.js 작성(sequelize.sync()로 모델과 서버 연결)

  9) passport 모듈 이용
    - 로그인 과정 처리를 도와주는 모듈
    - 패스워드 암호화를 위해 "bcrypt" 함께 설치
    - app.js 작성
      1) passport.initialize(): passport 설정
      2) passport.session(): req.session 객체에 passport 정보 저장
    
    - passport/index.js
      1) passport.serializeUser: req.session 객체에 어떤 데이터 저장할 지(사용자 id만 저장)
      2) passport.deserializeUser: req.session에 저장된 사용자 id로 db 조회 후 req.user에 저장
      3) strategy 이용
        - local(): local에서 로그인
        - kakao(): kakao에서 로그인, kakao API 이용

    - 로그인 과정
      1) 로그인 요청: html을 통해서 들어옴
      2) passport.authenticate 메소드
        : 첫 번째 인자는 strategy를 고름
        : 두 번째 인자는 콜백 함수로 done으로 넘어감
      3) 로그인 전략
      4) 로그인 성공 시 사용자 정보 객체와 함께 req.login 호출: req.login()은 passport를 init했을 때 연결이 된다.
      5) req.login 메소드가 passport.serializeUser 호출
      6) req.session에 사용자 아이디만 저장: 모든 객체를 가지고 있으면 메모리 부족 상태 일어날 수도 있다.
      7) 로그인 완료

    - 로그인 이후 과정
      1) 모든 요청에 passport.session() 미들웨어가 passport.deserializeUser 메소드 호출(바이트를 객체로 바꿈)
      2) req.session에 저장된 아이디로 DB에서 사용자 조회
      3) 조회된 사용자 정보를 req.user에 저장
      4) 라우터에서 req.user 객체 사용 가능: 사용자 id를 서버의 세션으로 저장

    - 로컬 로그인 구현
      : passport-local 패키지 이용
      : localStrategy.js 작성
        1) <input> 태그의 name과 필드 일치 필수
        2) bcrypt.compare()로 패스워드 비교

      : 사용자의 로그인 상태 미들웨어 추가

    - 다른 SNS 로그인 구현
      : passport-[해당 SNS] 패키지 이용
      : [해당 SNS]Strategy.js 작성
      : bcrypt.hash(패스워드, 반복 횟수)로 암호화
      ex) Kakao 로그인 구현
        1) clientID 필드에 Kako API key 추가
        2) callbackURL 필드에 Kakao의 결과를 받을 URL 추가
        3) accessToken, refreshToken: 로그인 성공 후 Kakao의 토큰
        4) profile: Kakao가 보내준 user 정보를 이용해 서버 로컬 DB에 회원 가입
        5) Kakao 로그인용 라우터 작성
          - /kakao와 /kakao/callback에 passport.authenticate("kakao")로 구현
          - 실패: failureRedirect: [URL]
          - 성공: res.redirect([URL])

    - 회원 가입(/join), 로그인(/login) 라우터 작성(auth.js)
      1) 회원 가입
        : passport.authenticate("local", 콜백 함수)로 로컬 전략 수행
        : 콜백 함수는 localStrategy.js의 done 함수와 매칭된다.

      2) 로그인: 인증이 성공하면 req.login()으로 세션에 유저 정보 저장

  10) Multer 모듈로 Image 업로드
    : 이미지는 파일 크기가 크기 때문에 <form> 태그의 enctype이 multipart/form-data 다.
    : body-parser로는 요청 본문 해석 불가 -> multer 패키지 이용

    - 이미지 업로드 방법 종류
      1) 이미지를 먼저 지정된 경로에 업로드 후 경로를 DB에 저장으로 사용자 요청 시 경로 응답
      2) 다른 방법으로 "BLOB"을 이용해 Image를 binary로 DB 내부에 저장 가능
    
    - Image 업로드 Router 구현
      1) fs.readdir([디렉토리 이름]), fs.mkdirSync([디렉토리 이름])로 upload 폴더가 없으면 생성(try-catch 이용)
      2) multer를 사용(diskStorage)
        : (req, file, done)의 미들웨어를 확장
        : destination, filename 지정(확장자 분리 후 filename은 현재 시간을 이용해 파일을 구분)
        : limits로 파일 최대 용량 지정
        : multer.single([파일명])을 통해서 Image를 읽고 req.file에 저장 
        : res.json({ url: `/img/${req.file.filename}` })로 반환

    - 게시글 등록
      1) 게시글 등록 시 먼저 받은 이미지 경로 저장
      2) 등록 시에 게시글의 해시 태그를 찾아 게시글과 연결
      3) MySQL의 findOrCreate()를 이용해 해시 태그가 존재하면 사용, 없으면 생성
        : map을 이용해 (모델, bool)을 모델로만 리스트로 구성시킨다.
        : MySQL의 add[모델명]()으로 row(= data) 추가

    - main 페이지에 게시글 보여주기
      1) main 페이지 요청 시=get("/") MySQL의 include로 관계가 있는 모델을 합쳐 가져옴(DBMS의 join)
      2) 템플릿 엔진 렌더링


* 기타 기능
  - 팔로잉 기능
    1) POST /:id/follow 이용(":id"에서 ':'는 동적으로 변할 때 사용, req.params.id로 접근 가능)
      ex) "louis"가 "ryul"을 팔로잉
        post("/ryul/follow", 미들웨어, (req, res, next){
          // req.params.id 로 접근
        });
    2) user.add[모델명] 로 row(= data) 추가
    3) deserializeUser() 수정
      : MySQL의 "include" 이용하여 User와 JOIN한 목록 조회
      : attributes 속성을 사용하여 제한된 조회로 비밀번호 유출 방지
    
    4) 처음 init하는 router.use(미들웨어) 수정
      : '?' 비교 연산자 사용하여 null 방지
    
  - 해시태그 검색 기능
    1) 해시태그를 먼저 찾기: router.get("/hashtag", 미들웨어), query.hashtag 이용
    2) 해시태그와 관련된 게시글 모두 찾기: hashtag.getPosts()

  - 업로드한 Image 제공(서버 내부 경로 감추기)
    1) express.static 미들웨어로 uploads 폴더에 저장된 Image 제공
      : front-end 에서는 /img/[Image URL]로 접근 가능 --- 서버 내부 경로 노출 방지
      ex) app.use("/img", express.static(path.join(__dirname, "uploads")));


=======================================================================================
#13

* API: Application Programming Interface
  - 다른 Application에서 현재 프로그램의 기능을 사용할 수 있도록 함

* Web API
  - 다른 웹 서비스의 기능을 사용하거나 자원을 가져올 수 있다.(크롤링)
  - 제한 종류
    1) 제공 대상 제한
    2) 횟수 제한
  
- nodebird-api: DB 접근해서 데이터 가져오고 JWT 토큰으로 인증

* WEB API Server
  - API 서버 Setting
    : 패키지 설치
    : 동일한 config, models, passport 사용
    : 라우팅 파일 사용(auth.js)
  
  - domain 모델 생성(models/domain.js)
    : API를 사용할 대상의 domain 저장 모델
    : ENUM type으로 free와 premium만 쓸 수 있도록 제한
    : clientSecret은 uuid type으로 만들어 client를 구분(ex. Kakao API Key)

  - domain 등록 라우터
    : uuid 패키지로 사용자가 등록한 domain에 고유한 비밀번호 부여
    : uuid는 충돌 위험이 있지만 매우 희박(고유하지 않다)
    : 비밀번호가 일치하는 요청만 API 응답

  - domain 등록 후 비밀번호 발급받기
    : 로그인 후 API Key 받기
    : domain 다른 Front-end에서 요청을 보내면 CORS(Cross Origin Resource Sharing) 에러 발생

  - JWT(JSON Web Token) 사용
    : Header.Payload.Signature로 구성됨
      1) Header: Token 종류와 Hash 알고리즘 정보가 들어있음
      2) Payload: Token의 내용물이 Encoding된 부분
      3) Signature: Token 변조 여부 확인, JWT 비밀키로 만들어짐(서버 내부에 저장)
    
    : 특징
      1) Payload 내용 조회 가능 --- 장점
      2) Token 변조 불가능 --- 장점
      3) DB 조회 없이 가능(내용물이 들어 있으므로) --- 장점
      4) 용량이 크므로 요청 시 데이터 양 증가 --- 단점

    : 설치
      - npm install --save jsonwebtoken
    
    : 사용
      - JWT 비밀키를 ".env"에 저장
      - verifyToken 미들웨어 작성
      - verify([req.headers.authorization], [비밀키]) 메소드로 검사
        : req.headers.authorization에 Token이 들어있음

      - 만료된 JWT Token은 419 에러 상태 코드
      - 유효하지 않은 Token은 401 에러 상태 코드
      - req.decoded에 payload를 넣어 다음 미들웨어에서 처리하게 함

    : JWT Token 발급 Router 만들기
      - version 마다 작성하여 기존 API를 사용하는 host에게 피해 X
      - 수정 사항이 생기면 Router 파일 작성(버전 업그레이드)
      - POST /token에서 JWT Token 발급
      - domain 검사 후 등록된 도메인이면 jwt.sign([페이로드], [비밀키], [토큰옵션]) 메소드로 JWT Token 발급
      - expiresIn: "유효 기간(분 단위 or 밀리초 단위)", issuer: "발급자"로 Token Option 지정

    : JWT Token으로 login
      - 세션 쿠키 대신 JWT 토큰을 쿠키로 발급: authenticate()의 두 번째 인자로 옵션 지정
        ex) passport.authenticate("전략", {session: false}, 콜백 함수)
        
    : Client에서 JWT 사용
      - RSA 같은 양방향 비대칭 암호화 알고리즘을 사용
      - JWT는 PEM Key를 사용(양방향 암호화)

* API 호출 서버(just 확인용) = nodecat
  - axios 모듈: http 클라이언트
    ex) axios.post(): 웹 브라우저에서 주소(도메인)치는 것이랑 같은 효과
  - token 테스트용 라우터 작성: routes/index.js

* NodeCat가 요청 -> NodeBird-API가 DB를 조회하여 데이터를 제공
  - nodebird의 데이터 제공
    : nodebird-api의 라우터 작성
      1) GET/posts/my
      2) GET/posts/hashtag/:title

  - nodecat의 데이터 가져오기
    : 요청은 axios로 보내고 세션 토큰 검사, 재발급까지 같이 수행
    : nodecat의 라우터 작성
      1) GET/mypost
      2) GET/search/:hashtag

* 사용량 제한 구현(nodebird-api)
  - DOS 공격 대비(Distributed-DOS): 무차별적인 API 요청
  - express-rate-limit 모듈
    - 설치: npm install express-rate-limit --save
    - 속성
      1) windowMS(기준 시간)
      2) max(허용 횟수)
      3) delayMS(호출 간격)
      4) handler(제한 초과 시 콜백 함수)
  

* CORS 이해
  - Cross Origin Resource Sharing
  - 요청을 보내는 Front와 요청을 받는 서버가 다르면 Error 발생(브라우저에서 제재)
    ex) 사용자는 'A'에 요청했지만 'B'에서 응답을 받는 경우
  - 프로토콜, IP 주소, Port 번호를 검사
  - Access-Control-Allow-Origin 응답 헤더를 넣어주면 해결
    1) res.set 메소드로 직접 넣기
    2) CORS 패키지 사용
      - origin: "호스트 도메인" --- 없으면 '*' 모든 도메인 허용
      - credentials: true 로 Front와 Back-end가 쿠키 공유됨


- 유용한 미들웨어 패턴(미들웨어 확장)
  ex)
    router.use(미들웨어());

    // 두 코드 같은 효과

    router.use((req, res, next) => {
      // 중간에 넣을 코드
      미들웨어()(req, res, next);
    });


* 프록시 서버(Proxy Server)
  - CORS error는 브라우저 단계에서 검사 -> 서버와 서버 간의 요청/응답에는 CORS 에러 발생 X
  - 클라이언트 --통신-- [프록시 서버 --통신-- API 서버]: 서버


=======================================================================================
#14

* 웹 소켓
  - 실시간 양방향 데이터 전송을 위한 기술
  - ws 프로토콜 사용: 브라우저가 지원해야 함
  - Node.js는 "ws" or "socket.io" 패키지로 웹 소켓 사용 가능
  - 웹 소켓으로 연결은 한 번만 맺고, http와 포트 공유 가능, 성능 매우 좋음
  - 웹 소켓 이전
    1) Polling 방식
      - 주기적으로 클라이언트가 서버에 요청을 보내 업데이트 확인

    2) SSE(Server Sent Events)
      - EventSource 객체 사용
      - 처음에 클라이언트가 한 번만 연결하면 서버가 클라이언트에 지속적으로 데이터 전송
      - 클라이언트에서 서버로는 데이터 보낼 수 없다.

* ws 모듈로 웹 소켓 구현
  - 웹 소켓 서버
    ex) app.js
      ...
      const webSocket = require("./socket");

      const server = app.listen(app.get("port"), () => {
        console.log(app.get("port"), "번 포트에서 대기 중");
      });

      webSocket(server);

    ex) socket.js
      const WebSocket = require("ws");
      
      moudle.exports = (server) => {
        const wss = new WebSocket.Server({ server });

        wss.on("connection", (ws, req) => {   // 웹 소켓 연결 시
          const ip = req.headers["x-forwarded-for"] || req.connection.remoteAddress;    // Client의 ip 알아내기
          
          ws.on("message", (message) => {
            // Client로부터 메시지 수신 시
          });
          ws.on("error", (err) => {
            // Error 발생 시
          });
          ws.on("close", () => {
            // 연결 종료 시
            clearInterval(ws.interval);   // 인터벌 해제
          });

          ws.interval = setInterval(() => {
            if(ws.readyState === ws.OPEN){
              ws.send("클라이언트가 받을 메시지");
            }
          }, 3000)  // 3초마다 send()
        });
      };
    
    - Front(Client)
      ex) index.html
        <script>
          let webSocket = new WebSocket("ws://localhost:8005");
          webSocket.onopen = function() {
            // 연결 성공
          }
          webSocket.onmessage = function(event){
            // 메시지 받을 시에 이벤트 리스너
            webSocket.send("서버로 메시지 보내기");   // 서버로 메시지 보내기
          }
        </script>


* Socket.IO 이용
  - 설치: npm install socket.io --save
  - Socket.IO는 먼저 polling 방식으로 연결 후(for. 웹 소켓을 지원 안하는 브라우저), 웹 소켓 사용 가능하면 업그레이드
  - 'transports' 속성으로 웹 소켓만 사용하도록 가능하다.
    ex) transports: ["websocket"]

  - 웹 소켓 서버
    ex) socket.js
      const SocketIO = require("socket.io");

      module.exports = (server) => {
        const io = SocketIO(server, { path: "/socket.io" });    // 여기다 transports 옵션 가능

        io.on("connection", (socket) => {
          // 웹 소켓 연결됨
          const req = socket.request;
          const ip = req.headers["x-forwarded-for"] || req.connection.remoteAddress;
          console.log("Client 접속!", ip, socket.id, req.ip);
          socket.on("disconnect", () => {
            // 연결 끊김
            clearInterval(socket.interval);
          });
          socket.on("error", (err) => {
            // 에러 시
            console.error(err);
          });
          socket.on("reply", (data) => {
            // 클라이언트로부터 메시지 수신 시
            console.log(data);
          });
          socket.interval = setInterval(() => {
            socket.emit("news", "클라이언트에게 메시지 전송");    // socket.emit()으로 메시지 전송
          }, 3000);   // 3초마다
        });
      };

    - Front(Client)
      ex) index.html
        <script src="/socket.io/socket.io.js" />

        <script>
          const socket = io.connect("http://localhost:8005", {
            path: "/socket.io",
          });
          socket.on("news", function(data){
            console.log(data);
            socket.emit("reply", "메시지 전송");    // 서버로 메시지 전송
          })
        </script>


* 실시간 GIF 채팅방, 채팅 만들기
  - 패키지 구성
    : mongoose, multer, axios, color-hash: 익명 닉네임에 색깔을 줌
  
  - 스키마 생성
    1) 방(room) 정보: 방 제목, 최대 수용인원, 방장, 비밀번호, 만든 시기
    2) 채팅(chat) 정보: 방 id, 사용자, 채팅 내용, gif 파일, 채팅 시기
  - 스키마 연결
    : express와 mongoose를 연결
  
  - Front-end
    1) main.html
      - io.connect(주소/네임스페이스) 사용
      - 같은 namespace 끼리 데이터 전달 가능(socket.io에는 io 객체 아래에 namespace가 있다)
      - socket에 newRoom(방 생성 시 목록에 방 추가 이벤트) 이벤트 연결
      - socket에 removeRoom(방 폭파 시 목록에서 방 제거 이벤트) 이벤트 연결
    2) chat.thml
      - /chat namespace에 연결
      - join 이벤트(방에 참가하면 시스템 메시지 등록) 연결
      - exit 이벤트(방에서 나갈 때 나갔다는 시스템 메시지 등록) 연결

  - socket.js 수정
    : app.set("io", io); 로 라우터에서 io 객체를 사용 가능하다.(req.app.get("io")로 접근)
    : io.of로 namespace에 접근한다.
    : 각각의 namespace에 이벤트를 따로 걸어준다.
    : req.headers.referer에 요청 주소가 들어 있고, 요청 주소에서 방 id를 추출한다.
    : socket.join(방 id)으로 방 입장
    : socket.leave(방 id)로 방 퇴장

  - color-hash 적용
    : 세션에 컬러 id 저장(req.session.color)
    ex)
      const colorHash = new ColorHash();
      req.session.color = colorHash.hex(req.sessionID);

  - socket.io에서 세션 사용
    : app.js에서 session을 바로 사용하지 않고 미들웨어로서 구성
      ex)
        const sessionMiddleware = session( { ... } );
        ...
        app.use(sessionMiddleware);
        ...
        webSocket(server, app, sessionMiddleware);    // socket.io에서 사용

    : socket.js에서 io.use()로 express 미들웨어를 사용
      ex)
        module.exports = (server, app, sessionMiddleware) => {
          const io = SocketIO(server, {path: "/socket.io"});
          app.set("io", io);
          const room = io.of("/room");
          const chat = io.of("/chat");

          io.use((socket, next) => {    // express 미들웨어 사용
            sessionMiddleware(socket.request, socket.request.res, next);
          });

          ...
        };

  - 방 입장, 퇴장 메시지 전송
    : to(방 id).emit(이벤트, 메시지)로 특정 방에 데이터 전송
    : socket.adapter.rooms[방 id]로 소켓 id 목록이 나옴
      ex) const currentRoom = socket.adapter.rooms[roomId];
    : 사용자가 0명이면 방 폭파(axios 이용하여 http 요청), 아니면 system 메시지
      ex)
        const userCount = currentRoom ? currentRoom.length : 0;
        if(userCount === 0){
          axios.delete(`http://localhost:8005/room/${roomId}`)    // DB 작업은 라우터가 하는 것을 권장
            .then(() => {
              // 성공
            })
            .catch((err) => {
              // 에러
            });
        } else {
          socket.io(roomId).emit("exit", {
            user: "system",
            char: `${req.session.color}님이 퇴장하셨습니다.`,
          });
        }

  - 라우터 작성
    : routes/index.js
      1) GET /
        - 메인 페이지(방 목록) 접속 라우터
      2) GET /
        - 방 생성 화면 라우터
      3) POST /room
        - 방 생성 요청 라우터
      4) GET /room/:id
        - 방 입장 라우터
      5) DELETE /room/:id
        - 방 제거 라우터
    : 방 최대 인원보다 작은 경우에 접속
      1) req.app.get("io")로 io 객체를 로드
      2) io.of(네임스페이스).adapter[방 id]로 방에 들어있는 소켓 내역 확인
      3) .length로 방 인원 확인

  - 실행
    : 브라우저 2개를 띄워 접속(ex. chrome, edge)
    : 하나의 브라우저에서 돌릴 경우, 세션이 유지돼 에러 발생

  - 채팅 구현(Front)
    : chat.html
      - chat 이벤트 리스너를 추가
      - 채팅 메시지가 웹 소켓으로 전송될 때 호출됨
      - <div>, <img> 등을 만들어 appendChild로 메시지가 보이게 됨.
      - event.data.user(채팅 발송자)에 따라 다르게 렌더링

  - 방에 접속하는 라우터 만들기
    ex) routes/index.js
      router.get("/room/:id", async(req, res, next) => {
        // DB에서 방 id를 찾아줌(방이 존재한지)
        // 비밀번호 맞는지 확인
        // 인원 체크

        // 마지막으로 chat 내용들을 find() 해준다.
      });
  
  - 채팅 라우터 만들기
    ex) routes/index.js
      router.post("/room/:id/chat", async(req, res, next) => {
        // DB에 채팅 내용 저장(옵션): 나중에 들어온 사람도 내용을 보게 함
        // 채팅 내용을 다른 사용자에게 뿌려줌
        req.app.get("io").of("/char").to(req.params.id).emit("chat", chat);
      });

  - 기타 Socket.IO API
    1) socket.to(소켓 id).emit(이벤트, 데이터);
      - 특정인에게 메시지 보내기
    2) socket.broadcast.emit(이벤트, 데이터);
      - 전체에게 메시지 보내기
    3) socket.broadcast.to(방 id).emit(이벤트, 데이터);
      - 특정 방에 전체에게 메시지 보내기

  - GIF 전송 구현
    : multer 모듈 사용
    : 이미지 저장 후, 파일 경로는 chat 데이터에 뿌림
    : 이미지를 제공할 static 폴더 연결
      ex) app.use("/gif", express.static(path.join(__dirname, "uploads")));



=======================================================================================
#15

* 문서(D) 객체(O) 모델(M)
  - "DOM"(Document Object Model)이라 함.
    : 웹 브라우저가 HTML Page를 인식하는 방법(= 넓은 의미)
    : document 객체와 관련된 객체의 집합(= 좁은 의미)
  - 문서 객체
    : HTML 태그를 Javascript에서 사용 가능한 객체로 만듦.
    : 문서 객체를 조작한다 = 태그를 조작한다
  - 노드: 각 요소
    1) 요소 노드: <h1>, <script> 처럼 요소를 생성하는 노드
    2) 텍스트 노드: 화면에 출력되는 문자열
  - 정적으로 문서 객체 생성(정적 페이지)
    : 웹 페이지를 처음 실행할 때 HTML 페이지의 태그를 읽으면서 생성
  - 동적으로 문서 객체 생성(동적 페이지)
    : Javascript를 사용해 프로그램 실행 중에 문서 객체를 생성


* 웹 페이지
  - 생성 순서: HTML 코드를 위에서 아래로 실행
  - HTML 표준: <script>를 <head>에 작성
    ex) 이벤트 기능 사용
      <head>
        <script>
          window.onload = function(){     // window가 전체가 렌더링 되었을 때, 처리하겠다.
            document.querySelector("h1").style.backgroundColor = "red";

            document.querySelector("h2").style.color = red;
          };
        </script>
      </head>


* 문서 객체 선택
  - HTML 태그를 Javascript 에서 문서 객체로 변환
  - 문서 객체를 선택하면 Javascript 로 실행 중에 내부 글자를 변경하거나 스타일 변경 가능
  - 문서 객체 선택 메소드
    1) document.getElementById(아이디명): id(한 개)를 사용해 문서 객체 선택
      ex) 글자색 바꾸기
        <body>
          <h1 id="header">Title</h1>
        </body>
        <script>
          let header = document.getElementById("header");
          header.style.color = "red";
        </script>
    2) document.getElementsByClassName(클래스명): 클래스(여러 개)를 사용해 문서 객체 선택
    3) document.querySelector(선택자): tag(ex. <div>, <h1>)를 사용해 문서 객체 선택
      - 여러 개 있으면 첫 번째 태그만, 여러 개면(querySelectorAll() 사용)

* 문서 객체 조작
  - innerHTML 속성 이용: 객체 내부의 글자
    ex) document.getElementById("header").innerHTML
  - style 속성 이용: 스타일 조작 가능
  - setAttribute(속성 이름, 속성 값), getAttribute(속성 이름) 이용하여 사용자 정의 속성 조작

* 이벤트
  : 키보드로 키를 입력하거나 마우스 클릭 등 어떤 현상이 프로그램 영향에 미치는 것
  - 이벤트 속성: onload --- 'on' + 이벤트 타입
  - 이벤트 이름, 이벤트 타입: load
  - 이벤트 리스너, 이벤트 핸들러: 이벤트 속성에 넣는 함수
  - 이벤트 모델: 문서 객체에 이벤트를 연결하는 방법
    1) 인라인 이벤트 모델: 태그 내부에 바로 연결
      ex) <button onclick="alert("click")">버튼</button>
    2) 고전 이벤트 모델
      ex) 
        <script>
          window.onload = function(){
            let button = document.getElementById("button");
            button.onclick = function(){
              alert("click");
            };
          };
        </script>
        <button id="button">버튼</button>

    3) 표준 이벤트 객체
      ex) 모든 웹 브라우저에서 이벤트 객체 사용
        <script>
          window.onload = function(e){
            let event = e || window.event;      // e는 표준 event 객체, 익스플로러는 window.event
          }
        </script>
    
  - 기본 이벤트 제거
    : 해당 이벤트 리스너를 return false; 해준다.
    ex)
      button.onclick = function() {
        return false;
      };



=======================================================================================
#16

* D3.js
  - Data-Driven Documents
    : Document를 Data를 기반으로 처리하는 Javascript 라이브러리

* 웹에서의 정보 시각화
  1) HTML: 웹 문서의 골격
  2) CSS: 스타일 지정
  3) Javascript: 문서 객체의 조작

- HTML의 tag들 중 그리기 요소를 갖고 있는 tags: <canvas>, <svg>
- D3.js에서는 기본값으로 SVG 사용, 경우에 따라서 canvas에 WebGL 사용하여 그리는 경우도 존재


=======================================================================================
#17

=======================================================================================